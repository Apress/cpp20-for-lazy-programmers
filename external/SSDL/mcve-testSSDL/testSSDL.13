#include <sstream>
#include <cstring> 
#include <string>
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_ttf.h>
#include <memory>

using namespace std;

struct SSDL_Color : public SDL_Color
{
public:
  constexpr SSDL_Color (SDL_Color& other) : SDL_Color(other) {}
  constexpr SSDL_Color (int rIn = 0, int gIn = 0, int bIn = 0, int alpha = 255) : SDL_Color()
  {
    r = rIn; g = gIn; b = bIn; a = alpha;
  }
  constexpr SSDL_Color            (const SSDL_Color& other) = default;
  constexpr SSDL_Color& operator= (const SSDL_Color& other) = default;
	
  constexpr bool operator== (const SSDL_Color& other) const
  {
    return r == other.r && g == other.g&& b == other.b && a == other.a;
  }
};

inline constexpr SSDL_Color SSDL_CreateColor (int r, int g, int b, int a=255) { return SSDL_Color (r, g, b, a); }

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), GREEN (0, 255, 0);

class SSDL_Font
{
public:
  SSDL_Font(TTF_Font* font = NULL) : ttfFont_(NULL)
  {
    ttfFont_.reset(font, TTF_CloseFont);
  }
  SSDL_Font(const SSDL_Font& f) { *this = f; }

  const SSDL_Font& operator= (const SSDL_Font& f) { ttfFont_ = f.ttfFont_; return *this; }
  operator       TTF_Font* ()       { return ttfFont_.get(); }
  operator       TTF_Font* () const { return ttfFont_.get(); }

private:
  std::shared_ptr<TTF_Font> ttfFont_;
};

bool matchFromEnd(const char* str, const char* substr)
{
  char* strEnd = (char*)str + strlen(str) - 1;
  char* substrEnd = (char*)substr + strlen(substr) - 1;

  for (;; --strEnd, --substrEnd)
    {
      if (toupper(*substrEnd) != toupper(*strEnd))  return false;

      if (substrEnd <= substr)    return true;
      else if (strEnd <= str)     return false;
    }
}

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
  std::string newPath(fontPath); newPath += filename;
  if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
  return newPath;
}

SDL_Window*   sdlWindow_;
SDL_Renderer* sdlRenderer_;
TTF_Font*     currentFont_;
std::string   systemFontPath_;
SSDL_Color    background_;
bool          isTimeToQuit_;
enum {DEFAULT_WIDTH = 640, DEFAULT_HEIGHT = 480};

void RenderTextLine    (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
void RenderText        (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);


int fontLineSkip ()
  {
    return TTF_FontLineSkip((TTF_Font*) currentFont_);
  }

inline void SSDL_SetRenderDrawColor (const SSDL_Color& c)
{
  SDL_SetRenderDrawColor(sdlRenderer_, c.r, c.g, c.b, c.a);   
}

inline SSDL_Color SSDL_GetRenderDrawColor ()
{
  SSDL_Color c;
  SDL_GetRenderDrawColor (sdlRenderer_, &c.r, &c.g, &c.b, &c.a);
  return c;
}

inline void SSDL_SetRenderEraseColor (const SSDL_Color& c)
{
  background_ = c;
}

inline void SSDL_RenderClearAux ()
{
  if (SDL_RenderClear (sdlRenderer_) < 0) throw "Oh, no!";
}

void SSDL_RenderClear(const SSDL_Color& c = background_);

inline
void SSDL_RenderTextAux (const char* str, int x, int y, const TTF_Font* font = currentFont_)
{
  RenderText (str, x, y, font);
}

template <typename T>
inline
void SSDL_RenderText (const T& thing, int x, int y, const TTF_Font* font = currentFont_)
{
  std::ostringstream os; os << thing;
  SSDL_RenderTextAux (os.str().c_str(), x, y, font);
}

inline void SSDL_RenderImage (SDL_Texture* image, const SDL_Rect& src, const SDL_Rect& dst)
{
  if (SDL_RenderCopy (sdlRenderer_, image, &src, &dst) != 0) throw "Oh, no!";
}

inline void SSDL_RenderPresent () { SDL_RenderPresent (sdlRenderer_); }

//Various functions related to I/O (mouse or keyboard)

typedef SDL_Event SSDL_Event; //simple renaming -- now you can use either


SDL_Keycode SSDL_WaitKey  (); //SDL_Keycode is SDL's virtual key rep. *Sometimes* casting to char gets you what you hit


inline bool isNumLockOn (SDL_Keymod mod) { return (mod & KMOD_NUM) != 0; }



static bool isEscapeMeansQuit = true;

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{
  return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
  if (sdlEvent.type == SDL_QUIT) isTimeToQuit_ = true;
  if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
      && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
    isTimeToQuit_ = true;
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
  SSDL_RenderPresent();

  while (!isTimeToQuit_)
    {
      if (SDL_WaitEvent(&sdlEvent) == 0) throw "Oh, no!";
      SSDL_CheckForQuitMessages(sdlEvent);
      if (sdlEvent.type == eventType) return;
    }
}

//This is the SSDL_Display -- the screen you see when the program runs. 

#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"

void init ()
{
  isTimeToQuit_ = false;
  if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
    throw "Oh, no!";


  sdlWindow_ = SDL_CreateWindow("",              //no title by default
				SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
				DEFAULT_WIDTH, DEFAULT_HEIGHT,
				0);           //flags are 0 by default
  if (!sdlWindow_) throw "Oh, no!";

  int rendererIndex = -1;
  int rendererFlags = 0;
  sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

  if (!sdlRenderer_) throw "Oh, no!";

  SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

  SDL_ClearError();
    
  static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
  if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw "Oh, no!";

  if (TTF_Init() == -1) throw "Oh, no!";

  SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);

  std::string finalFilename;

  systemFontPath_ = UBUNTU_FONT_PATH;
  finalFilename = SSDL_SystemFontPath(systemFontPath_.c_str(), "arial.ttf");
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), 14);
  if (!currentFont_)
    {
      std::string errorMsg = std::string("Missing arial.ttf") + 
	". Either msttcore fonts aren't installed or the path to them is unknown.\n"
	"If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";

      throw "Oh, no!"; 
    }

  TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

void RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  char* temp = new char[strlen(str) + 1]; 
  strcpy(temp, str);

  char* nextLine = strtok(temp, "\n\r");
  while (nextLine)
    {
      RenderTextLine(nextLine, x, y, font, isCentered);
      y += fontLineSkip();
      nextLine = strtok(NULL, "\n\r");
    }
  delete[] temp;
}

void RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  SDL_Surface* surfaceToPrintOn;
  surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());

  if (!surfaceToPrintOn) throw "Oh, no!";


  SDL_Texture* textureToPrint;
  textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

  if (!textureToPrint) throw "Oh, no!";

  int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
  SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

  if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
    throw "Oh, no!";

  SDL_DestroyTexture(textureToPrint);
  SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
  return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}

void SSDL_RenderClear(const SSDL_Color& c)
{
  SSDL_Color old = SSDL_GetRenderDrawColor();
  SSDL_SetRenderDrawColor(c);
  SSDL_RenderClearAux();
  SSDL_SetRenderDrawColor(old);
}

//This is SSDL_Font, a wrapper for TTF_Font


TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
  string finalFilename;
  TTF_Font* currentFont_; //WSB: change to "result"

  finalFilename = SSDL_SystemFontPath(systemFontPath_.c_str(), filename);
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);

  if (!currentFont_) 
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      throw "Oh, no!";
    }
  return currentFont_;
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
  string finalFilename = filename;
  if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

  TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
  if (!result) 
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      throw "Oh, no!";
    }
  return result;
}



int  getMoreChars ()
{
  bool OKWereDone = false;
  int  numCharsRead = 0;
  int x = 0, y = 0;
  
  while (! OKWereDone) //Looks a lot like SSDL_WaitEvent...
  {
    SDL_Event event;
    SSDL_RenderPresent();

    while (SDL_PollEvent(&event) != 0)
    {
      SDL_Keymod   mod		= SDL_GetModState();
      bool	     isNumLock	= isNumLockOn(mod);
      SDL_Scancode scancode;

      //If a quit message came, let's get out.
      SSDL_CheckForQuitMessages(event);
      if (isTimeToQuit_)
      {
	OKWereDone = true;  break;
      }

      switch (event.type)
	{
	  /*	  case SDL_KEYDOWN:
		  scancode = event.key.keysym.scancode;
		  if (scancode == SDL_SCANCODE_RETURN || scancode == SDL_SCANCODE_RETURN2)
		  {
		  OKWereDone = true;

		  SSDL_RenderText (event.key.keysym.sym, x, y); x+= 10;
		  }
		  break;*/
	case SDL_TEXTINPUT:
	  SSDL_RenderText (event.text.text[0], x, y); x+= 10;
	}
      }
    }

  return numCharsRead;
}


int main (int argc, char** argv)
{
  init ();
  
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();
  getMoreChars ();
  
  return 0;
}
