#include <cmath> 
#include <cassert>
#include <sstream>
#include <cstring> 
#include <string>
#include <SDL.h>
#include <exception>
#include <cstring> 
#include <SDL_ttf.h>
#include <memory>

using namespace std;

struct SSDL_Color : public SDL_Color
{
public:
  constexpr SSDL_Color (SDL_Color& other) : SDL_Color(other) {}
  constexpr SSDL_Color (int rIn = 0, int gIn = 0, int bIn = 0, int alpha = 255) : SDL_Color()
  {
    r = rIn; g = gIn; b = bIn; a = alpha;
  }
  constexpr SSDL_Color            (const SSDL_Color& other) = default;
  constexpr SSDL_Color& operator= (const SSDL_Color& other) = default;
	
  constexpr bool operator== (const SSDL_Color& other) const
  {
    return r == other.r && g == other.g&& b == other.b && a == other.a;
  }
};

inline constexpr SSDL_Color SSDL_CreateColor (int r, int g, int b, int a=255) { return SSDL_Color (r, g, b, a); }

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), GREEN (0, 255, 0);

class SSDL_Font
{
public:
  SSDL_Font(TTF_Font* font = NULL) : ttfFont_(NULL)
  {
    ttfFont_.reset(font, TTF_CloseFont);
  }
  SSDL_Font(const SSDL_Font& f) { *this = f; }

  const SSDL_Font& operator= (const SSDL_Font& f) { ttfFont_ = f.ttfFont_; return *this; }
  operator       TTF_Font* ()       { return ttfFont_.get(); }
  operator       TTF_Font* () const { return ttfFont_.get(); }

private:
  std::shared_ptr<TTF_Font> ttfFont_;
};

TTF_Font* SSDL_OpenFont           (const char* filename, int point);

std::string SSDL_SystemFontPath(const char* fontPath, const char* filename);

TTF_Font* SSDL_OpenSystemFont  (const char* filename, int point);

//What font is current?
TTF_Font* SSDL_GetCurrentFont();
void      SSDL_SetFont(TTF_Font* newFont);

//Useful for adding (or not) ".ttf" to the end of filenames
bool matchFromEnd(const char* str, const char* substr);


class SSDL_Image;

class SSDL_Display
{
public:
  enum {DEFAULT_WIDTH = 640, DEFAULT_HEIGHT = 480};

  SSDL_Display                  (const SSDL_Display&) = delete;
  const SSDL_Display& operator= (const SSDL_Display&) = delete;

  static SSDL_Display& Instance ()
  {
    static SSDL_Display myInstance;
    return myInstance;
  }       

  void RenderTextLine    (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
  void RenderText        (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
  //void scrollVertically  (unsigned int pixels); //Not currently done; maybe nice in next version

  bool isTimeToQuit () const { return isTimeToQuit_; }
  void declareTimeToQuit ()  { isTimeToQuit_ = true; }

  operator SDL_Renderer* () const { return sdlRenderer_; }
  operator SDL_Window*   () const { return sdlWindow_;   }

  void setWindowSize (int w, int h);

  int  advance(char ch) const
  {
    int result;
    if (TTF_GlyphMetrics ((TTF_Font*) (const TTF_Font*) SSDL_GetCurrentFont(), ch, NULL, NULL, NULL, NULL, &result))
      throw "Oh, no!";
    return result;
  }
  int fontLineSkip () const
  {
    return TTF_FontLineSkip((TTF_Font*) SSDL_GetCurrentFont());
  }


  const SSDL_Color& background () const { return background_; }
  void     setBackground (const SSDL_Color& c) { background_ = c; }

  TTF_Font* currentFont() const { return currentFont_; }
  void setCurrentFont(TTF_Font* newFont) { currentFont_ = newFont; }
  const char* systemFontPath () const { return systemFontPath_.c_str();}

  SDL_Window*   sdlWindow_;
  SDL_Renderer* sdlRenderer_;
  TTF_Font*         currentFont_;
  std::string   systemFontPath_;
  SSDL_Color        background_;

  bool              isTimeToQuit_;

  SSDL_Display  ();       
  ~SSDL_Display ();
};



inline bool SSDL_IsQuit      () { return SSDL_Display::Instance().isTimeToQuit(); }
inline void SSDL_DeclareQuit () { SSDL_Display::Instance().declareTimeToQuit();   }

inline void SSDL_SetRenderDrawColor (const SSDL_Color& c)
{
  SDL_SetRenderDrawColor(SSDL_Display::Instance(), c.r, c.g, c.b, c.a);   
}

inline SSDL_Color SSDL_GetRenderDrawColor ()
{
  SSDL_Color c;
  SDL_GetRenderDrawColor (SSDL_Display::Instance(), &c.r, &c.g, &c.b, &c.a);
  return c;
}

inline void SSDL_SetRenderEraseColor (const SSDL_Color& c)
{
  SSDL_Display::Instance().setBackground (c);
}

inline void SSDL_RenderClearAux ()
{
  if (SDL_RenderClear (SSDL_Display::Instance()) < 0) throw "Oh, no!";
}

void SSDL_RenderClear(const SSDL_Color& c = SSDL_Display::Instance().background());

inline
void SSDL_RenderTextAux (const char* str, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
  SSDL_Display::Instance().RenderText (str, x, y, font);
}

template <typename T>
inline
void SSDL_RenderText (const T& thing, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
  std::ostringstream os; os << thing;
  SSDL_RenderTextAux (os.str().c_str(), x, y, font);
}

inline void SSDL_RenderImage (SDL_Texture* image, const SDL_Rect& src, const SDL_Rect& dst)
{
  if (SDL_RenderCopy (SSDL_Display::Instance(), image, &src, &dst) != 0) throw "Oh, no!";
}

inline void SSDL_RenderPresent () { SDL_RenderPresent (SSDL_Display::Instance ()); }

//SSDL_stream.h stuff

//Various functions related to I/O (mouse or keyboard)

typedef SDL_Event SSDL_Event; //simple renaming -- now you can use either

bool SSDL_IsKeyPressed (SDL_Keycode whichKey);
void SSDL_WaitEvent (Uint32 eventType, SDL_Event& event);

//int         SSDL_WaitMouse();
SDL_Keycode SSDL_WaitKey  (); //SDL_Keycode is SDL's virtual key rep. *Sometimes* casting to char gets you what you hit

void SSDL_ToggleEscapeIsQuit ();

inline int SSDL_PollEvent (SDL_Event& event) { return SDL_PollEvent (&event); }

void SSDL_DefaultEventHandler ();

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent);


//#include "SSDL_image.h"

#include <SDL_image.h>

inline
void SSDL_DestroyTexture(SDL_Texture*& p) 
{
  if (p) 
    { 
      SDL_DestroyTexture(p); 
      p = nullptr; 
    }
}

class SSDL_Image
{
public:
  SSDL_Image() : sdlTexture_(NULL)  {  }
  SSDL_Image (SDL_Texture* sdlTexture) : sdlTexture_ (NULL) 
  { 
    sdlTexture_.reset(sdlTexture, SSDL_DestroyTexture);
  }
  SSDL_Image(const SSDL_Image& other) { *this = other;  }

  operator       SDL_Texture* ()		 { return sdlTexture_.get (); }
  operator       SDL_Texture* () const { return sdlTexture_.get (); }
	
  const SSDL_Image& operator= (const SSDL_Image& other)
  {
    sdlTexture_ = other.sdlTexture_; return *this;
  }
private:
  std::shared_ptr<SDL_Texture> sdlTexture_;
};

SSDL_Image SSDL_LoadImage(const char* filename);







inline bool isNumLockOn (SDL_Keymod mod) { return (mod & KMOD_NUM) != 0; }



static bool isEscapeMeansQuit = true;

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{
  return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
  if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
  if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
      && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
    SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
  SSDL_RenderPresent();

  while (!SSDL_Display::Instance().isTimeToQuit())
    {
      if (SDL_WaitEvent(&sdlEvent) == 0) throw "Oh, no!";
      SSDL_CheckForQuitMessages(sdlEvent);
      if (sdlEvent.type == eventType) return;
    }
}

void SSDL_DefaultEventHandler()
{
  SSDL_Event event;

  while (SSDL_PollEvent(event))
    switch (event.type)
      {
      case SDL_QUIT:    SSDL_DeclareQuit(); break;
      case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();
      case SDL_WINDOWEVENT_MAXIMIZED:
      case SDL_WINDOWEVENT_RESTORED:    
      case SDL_WINDOWEVENT_SIZE_CHANGED:
      case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
	break;
      }
}

int  SSDL_WaitMouse()
{
  SDL_Event event;
  SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
  return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
  SDL_Event event;
  SSDL_WaitEvent(SDL_KEYDOWN, event);
  return event.key.keysym.sym;
}

//This is the SSDL_Display -- the screen you see when the program runs. 

#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"

SSDL_Display::SSDL_Display() : isTimeToQuit_(false)
{
  if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
    throw "Oh, no!";


  sdlWindow_ = SDL_CreateWindow("",              //no title by default
				SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
				DEFAULT_WIDTH, DEFAULT_HEIGHT,
				0);           //flags are 0 by default
  if (!sdlWindow_) throw "Oh, no!";

  //defaults below:  index shd be -1 (pick the first renderer that works best)
  //rendererFlags should be 0
  int rendererIndex = -1;
  int rendererFlags = 0;
  sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

  if (!sdlRenderer_) throw "Oh, no!";

  SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

  SDL_ClearError();
    
  static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
  if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw "Oh, no!";

  if (TTF_Init() == -1) throw "Oh, no!";

  SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);

  int point = 14;
  std::string filename = "arial.ttf"; 
  std::string finalFilename;

  systemFontPath_ = UBUNTU_FONT_PATH;
  finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
  if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
      std::string errorMsg = std::string("Missing ") + filename +
	". Either msttcore fonts aren't installed or the path to them is unknown.\n"
	"If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";

      throw "Oh, no!"; 
    }

  TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
}

TTF_Font* SSDL_GetCurrentFont()
{
  return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
  SSDL_Display::Instance().setCurrentFont(newFont);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
  strcpy(temp, str);

  char* nextLine = strtok(temp, "\n\r");
  while (nextLine)
    {
      RenderTextLine(nextLine, x, y, font, isCentered);
      y += fontLineSkip();
      nextLine = strtok(NULL, "\n\r");
    }
  delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  SDL_Surface* surfaceToPrintOn;
  surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
  //arg -- having to cast away that const again.  Why should I have to?
  //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
  //I can fix this with my own calls
  if (!surfaceToPrintOn) throw "Oh, no!";


  SDL_Texture* textureToPrint;
  textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

  if (!textureToPrint) throw "Oh, no!";

  int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
  SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

  if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
    throw "Oh, no!";
  //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
  //Another time perhaps
  SDL_DestroyTexture(textureToPrint);
  SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
  return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}

void SSDL_RenderClear(const SSDL_Color& c)
{
  SSDL_Color old = SSDL_GetRenderDrawColor();
  SSDL_SetRenderDrawColor(c);
  SSDL_RenderClearAux();
  SSDL_SetRenderDrawColor(old);
}

//This is SSDL_Font, a wrapper for TTF_Font

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
  std::string newPath(fontPath); newPath += filename;
  if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
  return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
  string finalFilename;
  TTF_Font* currentFont_; //WSB: change to "result"

  finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);

  if (!currentFont_) 
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      throw "Oh, no!";
    }
  return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
  char* strEnd = (char*)str + strlen(str) - 1;
  char* substrEnd = (char*)substr + strlen(substr) - 1;

  for (;; --strEnd, --substrEnd)
    {
      if (toupper(*substrEnd) != toupper(*strEnd))  return false;

      if (substrEnd <= substr)    return true;
      else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
  SSDL_Display::Instance(); 

  string finalFilename = filename;
  if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

  TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
  if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      throw "Oh, no!";
    }
  return result;
}



int  getMoreChars ()
{
  bool OKWereDone = false;
  int  numCharsRead = 0;
  int x = 0, y = 0;
  
  while (! OKWereDone) //Looks a lot like SSDL_WaitEvent...
    {
      SDL_Event event;
      SSDL_RenderPresent();

      while (SDL_PollEvent(&event) != 0)
	{
	  SDL_Keymod   mod		= SDL_GetModState();
	  bool	     isNumLock	= isNumLockOn(mod);
	  SDL_Scancode scancode;

	  //If a quit message came, let's get out.
	  SSDL_CheckForQuitMessages(event);
	  if (SSDL_Display::Instance().isTimeToQuit())
	    {
	      OKWereDone = true;  break;
	    }

	  switch (event.type)
	    {
	    case SDL_KEYDOWN:
	      scancode = event.key.keysym.scancode;
	      if (scancode == SDL_SCANCODE_BACKSPACE || (!isNumLock && scancode == SDL_SCANCODE_KP_BACKSPACE))
		{
		  bool charRemoved;

		  if (charRemoved) --numCharsRead;
		}
	      if (scancode == SDL_SCANCODE_RETURN || scancode == SDL_SCANCODE_RETURN2)
		{
		  OKWereDone = true;

		  SSDL_RenderText (event.key.keysym.sym, x, y); x+= 10;
		}
	      break;
	    case SDL_TEXTINPUT:
		  SSDL_RenderText (event.text.text[0], x, y); x+= 10;
	    }
	}
    }

  return numCharsRead;
}


int main (int argc, char** argv)
{
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();
  getMoreChars ();
  
  return 0;
}
