#include <cmath> //for sqrt
#include <sstream>
#include <cstring> //for strcmp
#include "SSDL.h" 

/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is SSDL_Color.h, which provides SSDL_Color:  just like SDL_Color, except that it has constructors

#include "SSDL_color.h"

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);

/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is ssdl_exception.cpp, which provides an exception class that SSDL throws

#include <SDL.h>
#include "SSDL_exception.h"

void SSDL_terminate() //DOES NOT GET CALLED when we are in the Debugger
{
    //yes, but how do I know what exception was thrown?
    //I *could* just call SDL_GetError again -- I think -- but the correct thing is to use
    //What will it display if the error was not SDL?
    try
    {
        throw;
    }
    catch (const SSDL_Exception& c)
    {
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", c, NULL); //SDL_GetError (), NULL);
    }

    abort();
}



/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //Various functions related to I/O (mouse or keyboard)

#include <SDL.h>
#include "SSDL.h" //for refreshDisplay

static bool isEscapeMeansQuit = true; //make this something that starts with "SSDL_"
//static bool isVisible = true;        
void SSDL_ToggleEscapeMeansQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{	//The !=0 at the end is to suppress a coercion from Uint8 to bool warning
    //SDL_GetScancodeFromKey:  SDL_GetKeyboardState returns an array that'll tell you
    // what scancodes are currently pressed.  We want to know which keys.  So we must
    // convert
    return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
    if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
    if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
        && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
        SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
    //if (isVisible) 
    SSDL_RenderPresent();
    //Why this?  because it's annoying to have the screen not update while you're
    //waiting for an event!

    while (!SSDL_Display::Instance().isTimeToQuit())
    {
        if (SDL_WaitEvent(&sdlEvent) == 0) throw SSDL_Exception();
        SSDL_CheckForQuitMessages(sdlEvent);
        if (sdlEvent.type == eventType) return;
    }
}

void SSDL_ToggleEscapeIsQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

void SSDL_DefaultEventHandler()
{
    SSDL_Event event;

    while (SSDL_PollEvent(event))
        switch (event.type)
        {
        case SDL_QUIT:    SSDL_DeclareQuit(); break;
        case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();

            //The rest of these you should probably leave alone.
                //First: if the window is minimized, make a note we don't need to draw it until it isn't
            //case SDL_WINDOWEVENT_MINIMIZED:    isVisible = false; break;

                //Second: if it stopped being minimized, make a note we DO need to draw it
        case SDL_WINDOWEVENT_MAXIMIZED:
        case SDL_WINDOWEVENT_RESTORED:     //isVisible = true; 

            //...and if it was just made visible, or was obscured and is now less so, or
            //  was resized, do an immediate update
        case SDL_WINDOWEVENT_SIZE_CHANGED:
        case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
            break;
        }
}

int  SSDL_WaitMouse()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
    return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_KEYDOWN, event);
    return event.key.keysym.sym;
}


/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is SSDL_Image.h.  Since it's a wrapper, it can handle whatever image formats
  //  SDL2_Image supports.

  //Essentially it's SDL_Texture* except that it has a destructor. 

#include <SDL.h>
#include "SSDL_display.h"
#include "SSDL_image.h"

SSDL_Image SSDL_LoadImage(const char* filename)
{
    SSDL_Display::Instance(); //be sure SDL is initialized before calling IMG_Load

    SDL_Surface* sdlSurface = IMG_Load(filename);
    if (!sdlSurface) throw SSDL_Exception();

    SDL_Texture* result = SDL_CreateTextureFromSurface(SSDL_Display::Instance(), sdlSurface);
    if (!result) throw SSDL_Exception(); //sure would be nice if we could convey what
    //file failed!
    SDL_FreeSurface(sdlSurface);

    return SSDL_Image(result);
}

/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
  claim that you wrote the original software. If you use this software
  in a product, an acknowledgment in the product documentation would be
  appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
  misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is the SSDL_Display -- the screen you see when the program runs. 

#include <exception>
#include <cstring> 
#include <SDL.h>
#include <SDL_ttf.h>
#include <SDL_image.h>
#include "SSDL_display.h"
#include "SSDL_image.h"
#include "SSDL_font.h"

#ifdef _MSC_VER                                 //If it's Visual Studio
#pragma warning(disable : 4996) //Disable the "feature" that makes strcpy an error!
#endif

#define WINDOWS_FONT_PATH "C:\\Windows\\Fonts\\"
#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#define FEDORA_FONT_PATH "/usr/share/fonts/msttcore/"
#define OPENSUSE_FONT_PATH "/usr/share/fonts/truetype/"
#define OPENSUSE_FONT_PATH_NEW "/usr/share/fonts/msttcorefonts/"
#define MANJARO_FONT_PATH "/usr/share/fonts/TTF"

//What's this crazy stuff here?  I need to ensure that SSDL_Display::Instance()
// is called (thus initializing SDL among other things) before main starts.
//This will do it.  Why do I care?  In case someone does something in main
// with an SDL feature like mouse cursor that I am not supporting.  It won't
// work till SDL is initialized.  Now it is.

//Weakness:  what if they do this SDL feature globally?  Then order of initialization
// is not guaranteed by C++.  But if they know enough to use an SDL feature, they
// should know enough not to do things with it before SDL is initialized.  So there.

//Will Briggs, 11-12-2015

SSDL_Display::SSDL_Display() : //background_ (0, 0, 0, 255), foreground_ (255, 255, 255, 255),
    isTimeToQuit_(false)
{
    std::set_terminate(SSDL_terminate);

    if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
        throw SSDL_Exception();


    sdlWindow_ = SDL_CreateWindow("",              //no title by default
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        DEFAULT_WIDTH, DEFAULT_HEIGHT,
        0);           //flags are 0 by default
    if (!sdlWindow_) throw SSDL_Exception();

    //defaults below:  index shd be -1 (pick the first renderer that works best)
    //rendererFlags should be 0
    int rendererIndex = -1;
    int rendererFlags = 0;
    sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

    if (!sdlRenderer_) throw SSDL_Exception();

    //sdlSurface_ = SDL_GetWindowSurface(sdlWindow_); //WSB: It would be polite to free this later

    //if (! sdlSurface_ ) throw SSDL_Exception ();

    //Some distros Unix, sometimes, don't start with a blank screen. Make them. 2021-06-08
    SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

    SDL_ClearError(); //Why? SDL2_Image documentation warns that IMG_Init does not necessarily
    // set the Error, so I figure I'd better clear it.  I hope it sets it if there's an error!
    static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
    if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw SSDL_Exception();

    if (TTF_Init() == -1) throw SSDL_Exception();

    //Had to avoid calling SSDL_SetRenderDrawColor because it calls SSDL_Display::Instance
    //which calls this ctor, and a thread-safe mechanism got this thing stuck waiting forever
    SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);//the default color for drawing is WHITE.  I don't use the constant
    //because I don't _know_ that it's been initialized yet.

    int point = 14;
    std::string filename = "arial.ttf"; //This default is recorded in C++20 for Lazy Programmers, so DON'T CHANGE
    std::string finalFilename;

#ifdef _WIN32
    systemFontPath_ = WINDOWS_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
#else //Unix
    systemFontPath_ = UBUNTU_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    if (!currentFont_) //OK, if it's not on the UBUNTU path, is it in the FEDORA path?
    {
        finalFilename = SSDL_SystemFontPath(FEDORA_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = FEDORA_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the OPENSUSE path?
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the new OPENSUSE path? I find different paths for different installs of msttcore-fonts
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH_NEW, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH_NEW;
    }
    if (!currentFont_)  //If not, is it in the MANJARO path?
    {
        finalFilename = SSDL_SystemFontPath(MANJARO_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = MANJARO_FONT_PATH;
    }
    /* //If none of these font paths work, you can add your own here like so:
       #define MY_OWN_DISTRIBUTION_FONT_PATH "/wherever/this/distribution/keeps/its/msttcore-fonts"
       if(!currentFont_)  //If not, is it in the font path for my distribution of Unix?
       {
       finalFilename = SSDL_SystemFontPath (MY_OWN_DISTRIBUTION_FONT_PATH, filename.c_str());
       currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
       systemFontPath_ = MY_OWN_DISTRIBUTION_FONT_PATH;
       }
    */
#endif

    if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Missing ") + filename +
            ". Either msttcore fonts aren't installed or the path to them is unknown.\n"
            "If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";
        //Look up a few lines for how to add your own fonts path.

        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
        //VS in debugger crashes (good) and shows you where (good) but doesn't
        // call the function specified in set_terminate (bad)
        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception(errorMsg.c_str());
    }

    TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
    //This should be done as soon as the error condition arises.  Can we make this happen?  I think so -- by
    // rigorously checking return values, from (for example) SDL_DestroyTexture.  But this would require extra code after
    // any particular call, and that seems costly.

    //const char* errorString = SDL_GetError ();
    //8-17-2017
    //In Windows 10, if there is no speaker connected, you get a new sound system error every time
    // you try to do something iwth a sound -- it won't just let it go
    //So for now, I won't let errors get reported.  This is not optimal.
    //if (errorString[0] != '\0') //if there's an error
    //                      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "SDL Error", SDL_GetError (), NULL);

    /*
      5-20-2020 MinGW never returns to the command prompt because of SDL_Quit, which undoubtedly relates
      to the unspecified order of constructing/destructing globals between files. Ergo: for now
      just don't do it. Fix later.
      TTF_Quit();
      IMG_Quit();
      //SDL_DestroyRenderer (sdlRenderer_); //not needed, but OK //It was noticeably causing delay, so I commented it out
      SDL_DestroyWindow(sdlWindow_); //not needed, but OK
      SDL_Quit ();
    */
}

TTF_Font* SSDL_GetCurrentFont()
{
    return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
    SSDL_Display::Instance().setCurrentFont(newFont);
}


void SSDL_RenderImage(SDL_Texture* image, int x, int y, int stretchWidth, int stretchHeight)
{
    SDL_Rect dst; //src is dimensions of image; dst is where it's goin on screen
    dst.x = x; dst.y = y;

    if (stretchWidth == 0 || stretchHeight == 0) //what if they put in 0 for either?  then dont' stretch
        SDL_QueryTexture(image, NULL, NULL, &dst.w, &dst.h); //get width and height of image
    else
    {
        dst.w = stretchWidth; dst.h = stretchHeight;
    }

    SDL_RenderCopy(SSDL_Display::Instance(), image, NULL, &dst);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
//It's possible that the str may contain \n or \r.  If so, it should be broken into lines
// and printed.  If centered, we need to remember the center point.  If not, we need to remember the starting point
{
    //This is all about splitting str by using strtok
    // Because std::string doesn't support this, I must do my own dynamic memory

    char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
    strcpy(temp, str);

    char* nextLine = strtok(temp, "\n\r");
    while (nextLine)
    {
        RenderTextLine(nextLine, x, y, font, isCentered);
        y += fontLineSkip();
        nextLine = strtok(NULL, "\n\r");
    }
    delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    SDL_Surface* surfaceToPrintOn;
    surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
    //arg -- having to cast away that const again.  Why should I have to?
    //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
    //I can fix this with my own calls
    if (!surfaceToPrintOn) throw SSDL_Exception();


    SDL_Texture* textureToPrint;
    textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

    if (!textureToPrint) throw SSDL_Exception();

    int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
    SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

    if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
        throw SSDL_Exception();
    //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
    //Another time perhaps
    SDL_DestroyTexture(textureToPrint);
    SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
    return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}


/*void SSDL_Display::scrollVertically (unsigned int pixels) //Not currently done; maybe nice in next version
  {
  SDL_Rect srcRect, destRec;
  srcRect.x = destRec.x = 0;
  srcRect.y = pixels;
  destRec.y= 0;
  srcRect.w = destRec.w = sdlSurface_->w; //If I need sdlSurface_, get it at last minute with SDL_GetWindowSurface
  srcRect.h = destRec.h = sdlSurface_->h - pixels;

  SDL_Surface* temp = SSDL_CopySurface (sdlSurface_);
  //SDL_FillRect (temp, &srcRect, SDL_MapRGB (sdlSurface_->format, 255, 255, 255));
  //I don't know if you can copy a surface onto itself...
  SDL_BlitSurface (temp, NULL, sdlSurface_, NULL);
  //SDL_BlitSurface (temp, &srcRect, sdlSurface_, &destRec); //I think it's not blitting -- I think the
  //then a bkgd-color rectangle at the bottom
  }
*/
void SSDL_RenderClear(const SSDL_Color& c)
{
    SSDL_Color old = SSDL_GetRenderDrawColor();
    SSDL_SetRenderDrawColor(c);
    SSDL_RenderClearAux();
    SSDL_SetRenderDrawColor(old);
}

void SSDL_Display::setWindowSize(int w, int h)
{
#ifdef __unix__
    SDL_Event e; while (SDL_PollEvent(&e));
#endif
    //In Unix sometimes if I don't to this, the
    //next call to SDL_GetWindowSize will get the old
    //dimensions, not the new. Go figure.

    SDL_SetWindowSize(SSDL_Display::Instance(), w, h);

#ifdef __unix__
    SDL_RenderPresent(SSDL_Display::Instance());
    for (int i = 0; i < 40; ++i) //Must be 6 or more to be reliable
        SDL_Delay(30);          //10 works; 1 doesn't
      //A single SDL_Delay(60); usually works
      //but sometimes does not
      //The current numbers 40x30, are there to make it work with OpenSuSe. Would like to have
      // a more rational long-term fix. Maybe SDL.org will have one by now.
#endif

  //Programs in the repository that fail on some unix installations unless I do this
  // are Ch2/[any but sound], ch4/search*, ch9/*, ch10/ticTacToeBoard, ch11/staircase

  //The earlier SDL_Event e;... line is also needed for ch11/spritefish* and possibly
  // for other programs with game loops
  //#elif __unix__
  //...
  //#endif
}


/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is a collection of functions for drawing shapes.

#include <cmath> 
#include "SSDL_draw.h"

#define PI 3.14159

//http://content.gpwiki.org/index.php/SDL:Tutorials:Drawing_and_Filling_Circles has another method
//it may look better but it's incomprehensible

void SSDL_RenderFillCircle(int xc, int yc, int radius)
{
    for (int dy = -radius; dy <= radius; ++dy)
    {
        //x^2 + y^2 = r^2, so x = sqrt (r^2 - y^2)
        int dx = int(sqrt(radius * radius - dy * dy) + 0.5);
        SSDL_RenderDrawLine(xc - dx, yc + dy, xc + dx, yc + dy);
    }
}

void SSDL_RenderDrawCircle(int xc, int yc, int radius)
{
    //What angleIncrement should we use?  one that subtends about a pixel
    //sin(angleIncrement) = 1 / radius
    double angleIncrement = asin(1.0 / radius);

    for (double angle = 0; angle <= 2 * PI; angle += angleIncrement)
    {
        int y = int(radius * sin(angle) + 0.5);
        int x = int(radius * cos(angle) + 0.5);
        SSDL_RenderDrawPoint(xc + x, yc + y);
    }
}

void SSDL_RenderDrawCircles(SSDL_Circle* circles, int count)
{
    for (int i = 0; i < count; ++i)
        SSDL_RenderDrawCircle(circles[i].x, circles[i].y, circles[i].radius);
}

void SSDL_RenderFillCircles(SSDL_Circle* circles, int count)
{
    for (int i = 0; i < count; ++i)
        SSDL_RenderFillCircle(circles[i].x, circles[i].y, circles[i].radius);
}


/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is SSDL_Font, a wrapper for TTF_Font

#include <string>
#include <cstring>
#include <sstream>
#include "SSDL_font.h"
#include "SSDL_exception.h"
#include "SSDL_display.h"

using namespace std;

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
    std::string newPath(fontPath); newPath += filename;
    if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
    return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
    string finalFilename;
    TTF_Font* currentFont_; //WSB: change to "result"

//      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "systemFontPath_", SSDL_Display::Instance().systemFontPath(), NULL);
    finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "final filename", finalFilename.c_str(), NULL);

    if (!currentFont_) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
                                                        //VS in debugger crashes (good) and shows you where (good) but doesn't
                                                        // call the function specified in set_terminate (bad)
                                                        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception();
    }
    return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
    char* strEnd = (char*)str + strlen(str) - 1;
    char* substrEnd = (char*)substr + strlen(substr) - 1;

    for (;; --strEnd, --substrEnd)
    {
        if (toupper(*substrEnd) != toupper(*strEnd))  return false;

        if (substrEnd <= substr)    return true;
        else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
    SSDL_Display::Instance(); //be sure SSDL is initialized...

    //We hope the filename ends in .ttf.  If not, and there's no extension, append it.
    //If not, and there is an (incorrect) extension, go ahead and append it, and watch it fail.

    string finalFilename = filename;
    if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

    TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
    if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
                                                        //VS in debugger crashes (good) and shows you where (good) but doesn't
                                                        // call the function specified in set_terminate (bad)
                                                        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception();
    }
    return result;
}

/*TTF_Font* SSDL_OpenFont (const char* filename, int point)
{
        SSDL_Display::Instance();  //be sure SSDL is initialized...

        //Laura Mercy, what a lot of code just to check for file extension!
        enum {MAXLENGTH=5};
        char ext [5];
        if (_splitpath_s (filename, NULL, 0, NULL, 0, NULL, 0, ext, MAXLENGTH))
        {
                ostringstream os; os << "Could not extract extension from filename " << filename <<"; max length is " << MAXLENGTH-1;
                SDL_SetError (os.str().c_str());
                throw SSDL_Exception ();
        }

        //and if it's not there, add it.  I don't check for the WRONG one; SDL_TTF can do that
        string finalFilename = filename;
        if (strcmp (ext, "") ==0) finalFilename += ".ttf";

        //SSDL_Display::Instance (); //be sure it's all set up BEFORE we try to load a font
        TTF_Font* result = TTF_OpenFont (finalFilename.c_str(), point);
        if (! result) throw SSDL_Exception ();
        return result;
}*/


/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is the SingletonManager: it's used to be sure that these singleton objects
  // are created before main starts and destructed after it ends. OK, we may go
  // easy on the destructor stuff -- it's not crucial

#include <string>
#include <SDL_image.h>
#include "SSDL_display.h"
#include "SSDL_sound.h"
#include "SSDL_singletonManager.h"

void atexitHandler();

class SSDL_SingletonManager
{
public:
    SSDL_SingletonManager()
    {
        atexit(atexitHandler);
        SSDL_Display::Instance();
        SSDL_SoundSystem::Instance();
    }
    std::string crashMessage;
};

static SSDL_SingletonManager singletonManagerInstance;

void setCrashMessage(const std::string& msg) { singletonManagerInstance.crashMessage = msg; }

void atexitHandler()
{
    if (singletonManagerInstance.crashMessage.length()) //if there was a crash message...display it
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", singletonManagerInstance.crashMessage.c_str(), NULL);

    //I comment out what's below because g++ on Unix has this freeze up on cleanup, and cleanup doesn't
    // matter as we're about to leave anyway. Maybe fix this someday.
 /*   if (SSDL_SoundSystem::Instance().initialized())
    {
        Mix_AllocateChannels(0); Mix_CloseAudio();
    }
    Mix_Quit();
    TTF_Quit();
    IMG_Quit();
    SDL_DestroyRenderer (SSDL_Display::Instance().sdlRenderer_);
    SDL_DestroyWindow   (SSDL_Display::Instance().sdlWindow_);
    SDL_Quit();*/
}


/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is the Sound System.  It provides. all access to sounds.

#include "SSDL_exception.h"
#include "SSDL_sound.h"

//SSDL SoundSystem
SSDL_SoundSystem::SSDL_SoundSystem(int freq, Uint16 format, int channels, int chunkSize)
{
    //Start SDL2_Mixer. Apparently you don't really need to...
    //int soundsSupported = Mix_Init(MIX_INIT_FLAC | MIX_INIT_MOD | MIX_INIT_MP3 | MIX_INIT_OGG);
    //if (!soundsSupported) throw SSDL_Exception();

    initializedOK_ = (Mix_OpenAudio(freq, format, channels, chunkSize) != -1); //8-7-2017
    if (!initializedOK_) SDL_ClearError(); //or we'll get this complaint later, when it makes no sense
    //I commented out all refs to throwing SSDL_Exception in SSDL_sound.*, so we could get by with this
    //It may not be the best solution.
    //Fix later.  8-7-2017

    //if (Mix_OpenAudio(freq, format, channels, chunkSize) == -1)
    //		throw SSDL_Exception (); 
}

Mix_Music* SSDL_Music::music_ = NULL;

void SSDL_PlaySound(const SSDL_Sound& sound, int repeats)
{
    int result = Mix_PlayChannel(sound, sound, repeats);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_FadeInSound(SSDL_Sound& sound, int repeats, int ms)
{
    int result = Mix_FadeInChannel(sound, sound, repeats, ms);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_PlaySoundTimed(SSDL_Sound& sound, int repeats, int ticks)
{
    int result = Mix_PlayChannelTimed(sound, sound, repeats, ticks);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_FadeInSoundTimed(SSDL_Sound& sound, int repeats, int ms, int ticks)
{
    int result = Mix_FadeInChannelTimed(sound, sound, repeats, ms, ticks);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}
/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is SSDL_Sprite.  A Sprite is a Texture (derived from an image) that also has a location.


#include "SSDL_sprite.h"

const SSDL_Sprite& SSDL_Sprite::operator= (const SSDL_Sprite& other)
{
    x_ = other.x_;				y_ = other.y_;
    width_ = other.width_;		height_ = other.height_;
    clipX_ = other.clipX_;		clipY_ = other.clipY_;
    clipWidth_ = other.clipWidth_; clipHeight_ = other.clipHeight_;
    offsetX_ = other.offsetX_;	offsetY_ = other.offsetY_;

    angleOfRotation_ = other.angleOfRotation_;
    flipVertical_ = other.flipVertical_;
    flipHorizontal_ = other.flipHorizontal_;

    SSDL_Image::operator= (other);

    return *this;
}

void SSDL_Sprite::zeroFields()
{
    x_ = y_ = 0;
    clipX_ = clipY_ = 0;
    offsetX_ = offsetY_ = 0;

    clipWidth_ = clipHeight_ = 0;

    width_ = clipWidth_;
    height_ = clipHeight_;

    angleOfRotation_ = 0.0;
    flipHorizontal_ = flipVertical_ = false;
}

void SSDL_Sprite::setImage(const SSDL_Image& t)
{
    SSDL_Image::operator= (t);

    zeroFields();

    if (t)
        SSDL_QueryImage(t, clipWidth_, clipHeight_);

    width_ = clipWidth_;
    height_ = clipHeight_;
}

SDL_Rect SSDL_Sprite::destination()	const	//rectangle that's where it'll go on the screen
{
    SDL_Rect result = { x_, y_, width_, height_ };
    result.x -= offsetX();		//apply offset
    result.y -= offsetY();
    return result;
}

SDL_Rect SSDL_Sprite::source() const		//rectangle that's where it's coming from in the image
{
    SDL_Rect result = { clipX_, clipY_, clipWidth_, clipHeight_ };
    return result;
}

void SSDL_RenderSprite(const SSDL_Sprite& sprite)
{
    SDL_Rect destination = sprite.destination();
    SSDL_RenderImageEx(sprite, sprite.source(), destination, sprite.angleOfRotation(),
        (SDL_RendererFlip)((int(sprite.flipHorizontal()) * SDL_FLIP_HORIZONTAL) | (int(sprite.flipVertical()) * SDL_FLIP_VERTICAL)));
}

bool SSDL_SpriteHasIntersection(const SSDL_Sprite& aIn, const SSDL_Sprite& bIn)
{
    SDL_Rect aDest = aIn.destination(), bDest = bIn.destination();
    return (SDL_HasIntersection(&aDest, &bDest) != SDL_FALSE);
}

/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //Timer-related functions.

#include "SSDL_color.h"
#include "SSDL_display.h"
#include "SSDL_timer.h"
#include "SSDL.h"

/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is SSDL stream I/O, culminating in sin (which reads from kbd, prints chars to output, and reads in text)
  // and sout (which prints to screen)

#include "SSDL_display.h"
#include "SSDL_stream.h"
#include "SSDL_io.h"

using namespace std;

static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
    SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
    //	SDL_Rect rect = {0, 0, 1, 1};

        //erase that last char by replacing with background color
    SDL_Rect newRect;
    newRect.x = cursorX(); newRect.y = cursorY();
    newRect.w = SSDL_Display::Instance().advance(c);
    newRect.h = SSDL_Display::Instance().fontLineSkip();
    Uint8 r, g, b, a;
    SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
    SSDL_Color background_ = SSDL_Display::Instance().background();
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
    SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
    SSDL_RenderPresent();

    SDL_FreeSurface(result);
}

/*
This code is not currently used, but I'll leave it in, in case it turns up useful later.

bool isPrintable(SDL_Scancode scancode, SDL_Keymod mod)
{
    if (SDL_SCANCODE_A <= scancode && scancode <= SDL_SCANCODE_0) //if it's alphanumeric...
        return true;
    if (SDL_SCANCODE_SPACE <= scancode && scancode <= SDL_SCANCODE_SLASH) //or from a bunch of punctuation keys...
        return true;
    if (isNumLockOn(mod) && isNumLockKey(scancode))
        return true;
    return false;
}

char myToupper(char c)
{
    if (isalpha(c)) return toupper(c);
    switch (c)
    {
    case '1': return '!';
    case '`': return '~';
    case '2': return '@';
    case '3': return '#';
    case '4': return '$';
    case '5': return '%';
    case '6': return '^';
    case '7': return '&';
    case '8': return '*';
    case '9': return '(';
    case '0': return ')';
    case '-': return '_';
    case '=': return '+';
    case '[': return '{';
    case ']': return '}';
    case '\\': return '|';
    case ';': return ':';
    case '\'': return '\"';
    case ',': return '<';
    case '.': return '>';
    case '/': return '?';
    default: return c;
    }
}
*/

class SSDL_Timer
{
public:
    static SSDL_Timer& Instance()
    {
        static SSDL_Timer myInstance;
        return myInstance;
    }

    SSDL_Timer(const SSDL_Timer&) = delete;
    const SSDL_Timer& operator= (const SSDL_Timer&) = delete;

    void setFramesPerSecond(Uint32 fps) { frameDuration_ = 1000 / fps; }
    //maybe I shd just do frame duration as 1/60 of a second?
    bool sync();
private:
    SSDL_Timer() : timeAtNextFrame_(0)
    {
        setFramesPerSecond(60);	//default to 60 frames per second.
    }

    Uint32 frameDuration_;		//in milliseconds
    Uint32 timeAtNextFrame_;	//in milliseconds, counting from time we started SDL
};

// Frame Per Second Function  , put this in a loop
bool SSDL_Timer::sync()
{
    if (SSDL_Display::Instance().isTimeToQuit()) return false;

    SSDL_RenderPresent();

    //SDL_GetTicks returns current time (since SDL was initialized)
    //if the time at the next frame is later than that, wait.  How long?  The difference
    Uint32 currentTime = SDL_GetTicks();
    if (timeAtNextFrame_ > currentTime)
        SDL_Delay(timeAtNextFrame_ - currentTime);

    //Now set the time at the next frame to the current time, plus the duration of one frame
    timeAtNextFrame_ = currentTime + frameDuration_;

    return true;
}

bool SSDL_IsQuitMessage()
{
    SSDL_DefaultEventHandler();
    return !SSDL_IsNextFrame();
}

void SSDL_SetFramesPerSecond(Uint32 FPS) { SSDL_Timer::Instance().setFramesPerSecond(FPS); }
bool SSDL_IsNextFrame() { return SSDL_Timer::Instance().sync(); }





SSDL_SoundSystemInitializer initializer (88020, MIX_DEFAULT_FORMAT,MIX_DEFAULT_CHANNELS, 4096);

//dimensions of screen and screen locations
enum {SCREEN_WIDTH=675, SCREEN_HEIGHT=522}; //dimensions of bkgd

enum {CANDY_START_HEIGHT = 15};  //where candy falls from

enum {MARGIN             = 25};  //As close to the left/right edges 
                                 // of the screen as moving objects
                                 // are allowed to get

enum {BOTTOM_LINE        = 480}; //Where last line of text is printed
                                 //on instruction & splash screens

//dimensions of important objects
enum { CANDY_WIDTH  = 60, CANDY_HEIGHT  = 20 };
enum { BASKET_WIDTH = 70, BASKET_HEIGHT = 90 };

//how many candies you can catch or miss before winning/losing
enum {MAX_CAUGHT         = 10,  MAX_MISSED= 10}; 
//If you change this, change 
// printInstructions too
// because it specifies this

//fonts for splash screens and catch/miss statistics
enum {SMALL_FONT_SIZE  = 12,
      MEDIUM_FONT_SIZE = 24,
      LARGE_FONT_SIZE  = 36};

const SSDL_Font SMALL_FONT 
  = SSDL_OpenFont ("../test/media/Sinister-Fonts_Werewolf-Moon/Werewolf Moon.ttf",
                 SMALL_FONT_SIZE);
const SSDL_Font MEDIUM_FONT
  = SSDL_OpenFont ("../test/media/Sinister-Fonts_Werewolf-Moon/Werewolf Moon.ttf", 
                 MEDIUM_FONT_SIZE);
const SSDL_Font LARGE_FONT 
  = SSDL_OpenFont ("../test/media/Sinister-Fonts_Werewolf-Moon/Werewolf Moon.ttf", 
                 LARGE_FONT_SIZE);

//how far our victory/defeat messages are from left side of screen
enum { FINAL_SCREEN_MESSAGE_OFFSET_X = 40 };

//background
const SSDL_Image BKGD_IMAGE     
  = SSDL_LoadImage("../test/media/haunted-house.jpg");

//sounds and music
const SSDL_Music BKGD_MUSIC
  = SSDL_LoadMUS("../test/media/159509__mistersherlock__halloween-graveyd-short.mp3");
const SSDL_Sound THUNK_SOUND
  = SSDL_LoadWAV("../test/media/457741__osiruswaltz__wall-bump-1.wav");
const SSDL_Sound DROP_SOUND   
  = SSDL_LoadWAV("../test/media/388284__matypresidente__water-drop-short.wav");

//structs
struct Point2D { int x_=0, y_=0; };

using Vector2D = Point2D; 

struct Object
{
  Point2D     loc_;
  int         rotation_      = 0; 

  Vector2D    velocity_;
  int         rotationSpeed_ = 0;

  SSDL_Sprite sprite_;
};

//major functions called by the main program
bool playGame            ();

//startup/ending screens to communicate with user
void printInstructions   ();
void displayVictoryScreen();
void displayDefeatScreen ();

int main (int argc, char** argv)
{
  //Test window functions
  SSDL_SetWindowTitle ("Window should be in top left corner of screen");
  assert(!strcmp(SSDL_GetWindowTitle(), "Window should be in top left corner of screen"));
  SSDL_SetWindowPosition(100, 100);
  int x, y; SSDL_GetWindowPosition(x, y); assert(x == 100); assert(y == 100);
  SSDL_SetWindowSize  (SCREEN_WIDTH, SCREEN_HEIGHT);
  assert(SSDL_GetWindowWidth() == SCREEN_WIDTH); assert(SSDL_GetWindowHeight() == SCREEN_HEIGHT);
  SSDL_SetWindowPosition(5, 5);

  /*
  //SDL in Unix has been flaking on minimize/maximize, so I'm commenting this out
  // maybe eventually it'll be fixed.
  //Tests the min/restore/max functions, plus SSDL_Dleay
  sout << "Hit a key; watch the window disappear, reappear, maximize, then come back to this size.\n";
  SSDL_WaitKey();
  SSDL_MinimizeWindow(); SSDL_Delay(500);
  SSDL_RestoreWindow (); SSDL_Delay(500);
  SSDL_MaximizeWindow(); SSDL_Delay(500); 
  SSDL_RestoreWindow();
  */
  
  ////Test exception
  try 
    {
      SSDL_Image img = SSDL_LoadImage("nonexistentFile.jpg");
      sout << "Should never reach this line!\n";
    }
  catch (SSDL_Exception& e) 
    {
      std::ostringstream os; 
      os << e; 
      assert(os.str() == std::string("Couldn't open nonexistentFile.jpg")); 
    }

  //Test image
  assert(SSDL_GetImageWidth(BKGD_IMAGE) == 675); assert(SSDL_GetImageHeight(BKGD_IMAGE) == 522);

  //Test GetMouse*: click, x, y; SSDL_IsQuit; SSDL_ToggleEscapeIsQuit
  assert(!SSDL_IsQuit());         //Too hard to test when it succeeds! But it's simple enough I'll let that go.
  SSDL_ToggleEscapeIsQuit();
  SSDL_SetCursor(0,0);
  sout << "Click mouse. Escape won't kill the program on this screen!\n";
  SSDL_WaitMouse();
  switch (SSDL_GetMouseClick())
    {
    case SDL_BUTTON_LEFT: sout << "Left button clicked.\n"; break;
    case SDL_BUTTON_RIGHT:sout << "Right button clicked.\n"; break;
    default: sout << "Unknown button clicked -- not left or right!\n";
    }
  sout << "You clicked at point (" << SSDL_GetMouseX() << ", " << SSDL_GetMouseY() << "). Click again!\n";
  SSDL_WaitMouse();

  //Now some music
  SSDL_VolumeMusic (int (MIX_MAX_VOLUME * 0.1));
  assert(!SSDL_PlayingMusic());
  SSDL_PlayMusic   (BKGD_MUSIC);
  assert(SSDL_PlayingMusic());
	
  //Test drawing, SSDL_ToggleEscapeIsQuit, RenderClear using erase color
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();

  SSDL_SetRenderDrawColor(WHITE);	SSDL_RenderFillCircle(100, 300, 49);
  SSDL_SetRenderDrawColor(RED);   SSDL_RenderDrawCircle(100, 300, 50);
  SSDL_RenderDrawPoint(100, 400);

  SSDL_SetRenderDrawColor(WHITE);	SSDL_RenderFillRect(200, 300, 90, 90);
  SSDL_SetRenderDrawColor(RED);   SSDL_RenderDrawRect(200, 300, 90, 90);
  SSDL_RenderDrawPoint(245, 345);

  SDL_Point points[5] = { {300,300},{390,300},{390,390},{300,390},{300,300} };

  SSDL_RenderDrawLines(points, 5);
  SDL_Rect rects[3] = { {300,300,30,20},{330,335,30,20},{360,370,30,20} };
  SSDL_SetRenderDrawColor(WHITE); SSDL_RenderFillRects(rects, 3);
  SSDL_SetRenderDrawColor(RED); SSDL_RenderDrawRects(rects, 3);
  SSDL_RenderDrawLine(0, 450, SCREEN_WIDTH, 450);

  SSDL_SetRenderDrawColor(WHITE);
  SDL_Rect rect = { 400,300,90,90 };
  SDL_Point measles[] = { {410,310},{450,350},{490,390} };
  SSDL_RenderDrawRect(rect);
  SSDL_RenderDrawPoints(measles, 3);

  //Test erase color, pause/resume music
  std::string str;

  SSDL_SetCursor(0, 0);
  sout << "Window is near upper left of screen.\n";
  sout << "Check out these figures : bordered circles and rects.\n";
  sout << "Default font, GREEN background.\n";
  sout << "Enter text. Backspace to see BLUE\n"; 
  sout << "Hit Esc all you want, until you enter the text.\n";
  sout << "Music will be audible when you go on.\n>";

  SSDL_SetRenderEraseColor(BLUE);
  assert(SSDL_GetRenderEraseColor() == BLUE);
  SSDL_PauseMusic(); assert(SSDL_PausedMusic());
  ssin >> str;
  SSDL_ResumeMusic(); assert(!SSDL_PausedMusic());

  SSDL_ToggleEscapeIsQuit();

  //initial splash screen
  SSDL_SetRenderEraseColor(BLACK); SSDL_RenderClear();
  printInstructions ();

  //The game itself
  bool isVictory = playGame ();

  //final screen:  victory or defeat
  SSDL_RenderClear (BLACK);
  SSDL_HaltMusic   ();
    
  if (isVictory) displayVictoryScreen ();
  else           displayDefeatScreen  ();

  SSDL_RenderTextCentered("Click mouse to end", 
			  SCREEN_WIDTH/2, BOTTOM_LINE, SMALL_FONT);
  SSDL_WaitMouse();  //Inherently tests SSDL_RenderPresent and SSDL_WaitEvent
  return 0;
}

//// Startup/ending screens to communicate with user ////

void printInstructions ()
{
  enum { LINE_HEIGHT = 40 };
  SSDL_SetRenderDrawColor (WHITE);
  SSDL_RenderTextCentered ("Catch 10 treats in ", 
			   SCREEN_WIDTH/2,              0, MEDIUM_FONT);
  SSDL_RenderTextCentered("your basket to win",
			  SCREEN_WIDTH/2, LINE_HEIGHT   , MEDIUM_FONT); 
  SSDL_RenderTextCentered ("Miss 10 treats and",
			   SCREEN_WIDTH/2, LINE_HEIGHT*3 , MEDIUM_FONT);
  SSDL_RenderTextCentered("the next treat is YOU",
			  SCREEN_WIDTH/2, LINE_HEIGHT*4 , MEDIUM_FONT);
    
  SSDL_RenderTextCentered ("Use arrow keys to move",
			   SCREEN_WIDTH/2, LINE_HEIGHT*6 , MEDIUM_FONT);
  SSDL_RenderTextCentered("left and right",
			  SCREEN_WIDTH/2, LINE_HEIGHT*7 , MEDIUM_FONT);
    
  SSDL_RenderTextCentered ("Click mouse to",
			   SCREEN_WIDTH/2, LINE_HEIGHT*9 , MEDIUM_FONT);
  SSDL_RenderTextCentered("toggle stats display",
			  SCREEN_WIDTH/2, LINE_HEIGHT*10, MEDIUM_FONT);
    
  SSDL_RenderTextCentered ("Hit any key to continue",
			   SCREEN_WIDTH/2, BOTTOM_LINE,    SMALL_FONT);

  SSDL_WaitKey      (); ///Inherently tests SSDL_RenderPresent and SSDL_WaitEvent
}

void displayVictoryScreen ()
{
  //sound and picture
  static const SSDL_Sound VICTORY_SOUND
    = SSDL_LoadWAV("../test/media/342153__robcro6010__circus-theme-short.wav");
  SSDL_PlaySound(VICTORY_SOUND);
  static const SSDL_Image GOOD_PUMPKIN
    = SSDL_LoadImage("../test/media/goodPumpkin.png");
  SSDL_RenderImage(GOOD_PUMPKIN, SCREEN_WIDTH / 4, 0); 

  //victory message
  SSDL_SetRenderDrawColor(WHITE);
  SSDL_RenderText ("Hooah!"  ,
		   FINAL_SCREEN_MESSAGE_OFFSET_X, SCREEN_HEIGHT/4, 
		   LARGE_FONT); 
  enum { LINE_DISTANCE_Y = 96 }; //an arbitrarily chosen number...
  SSDL_RenderText ("You won!",
		   FINAL_SCREEN_MESSAGE_OFFSET_X,
		   SCREEN_HEIGHT/4+LINE_DISTANCE_Y,
		   LARGE_FONT); 
}

void displayDefeatScreen ()
{
  //sound and picture
  static const SSDL_Sound DEFEAT_SOUND 
    = SSDL_LoadWAV("../test/media/326813__mrose6__echoed-screams-short.wav");
  SSDL_PlaySound(DEFEAT_SOUND);
  static const SSDL_Image SAD_PUMPKIN
    = SSDL_LoadImage("../test/media/sadPumpkin.png");
  SSDL_RenderImage(SAD_PUMPKIN, SCREEN_WIDTH / 4, 0);

  //defeat message
  SSDL_SetRenderDrawColor (WHITE);
  SSDL_RenderText ("Oh, no!", FINAL_SCREEN_MESSAGE_OFFSET_X,
		   SCREEN_HEIGHT/4, LARGE_FONT); 
}

///////////////////// Initializing /////////////////////////

void resetCandyPosition(Object& candy);

void initializeObjects (Object& basket, Object& candy, Object& yumMessage)
{
  //load those images
  SSDL_SetSpriteImage(candy.sprite_,
		      SSDL_LoadImage("../test/media/candy.png"));
  SSDL_SetSpriteImage(basket.sprite_,
		      SSDL_LoadImage("../test/media/jack-o-lantern.png"));
  SSDL_SetSpriteImage(yumMessage.sprite_,
		      SSDL_LoadImage("../test/media/yum.png"));

  //two images are the wrong size; we resize them.
  SSDL_SetSpriteSize (candy.sprite_,   CANDY_WIDTH,  CANDY_HEIGHT);
  SSDL_SetSpriteSize (basket.sprite_, BASKET_WIDTH, BASKET_HEIGHT);
  assert(SSDL_GetSpriteWidth(basket.sprite_) == BASKET_WIDTH);
  assert(SSDL_GetSpriteHeight(basket.sprite_) == BASKET_HEIGHT);

  //basket is 166x214. No, it's now 216x314. Clip out the extra to test clipping
  //clip basket
  SSDL_SetSpriteClipLocation(basket.sprite_, 50, 100);
  SSDL_SetSpriteClipSize(basket.sprite_, 166, 214);
  assert(SSDL_GetSpriteClipX(basket.sprite_) == 50);
  assert(SSDL_GetSpriteClipY(basket.sprite_) ==100);
  assert(SSDL_GetSpriteClipWidth(basket.sprite_) == 166);
  assert(SSDL_GetSpriteClipHeight(basket.sprite_) == 214);

  //flip basket
  SSDL_SpriteFlipVertical(basket.sprite_);
  assert(SSDL_GetSpriteFlipVertical(basket.sprite_));
  //I wont' test SSDL_SpriteFlipHorizontal -- assume it works the same way

  //move 'em so they're centered on the coords we set for them
  SSDL_SetSpriteOffset(candy.sprite_,
		       CANDY_WIDTH/2,  CANDY_HEIGHT/2);
  SSDL_SetSpriteOffset(basket.sprite_,
		       BASKET_WIDTH/2, BASKET_HEIGHT/2);

  //put the objects in their starting positions
  basket.loc_.x_ = SCREEN_WIDTH / 2;
  basket.loc_.y_ = SCREEN_HEIGHT - BASKET_HEIGHT/2;
  SSDL_SetSpriteLocation(basket.sprite_,
			 basket.loc_.x_, basket.loc_.y_);
  candy.loc_.x_ = basket.loc_.x_ + BASKET_WIDTH/2+CANDY_WIDTH/2 - 1; //just inside basket
  candy.loc_.y_ = basket.loc_.y_;
  SSDL_SetSpriteLocation(candy.sprite_, candy.loc_.x_, candy.loc_.y_);
  assert(  SSDL_SpriteHasIntersection(basket.sprite_, candy.sprite_));
  candy.loc_.x_ += 2; //now it's just outside the basket
  SSDL_SetSpriteLocation(candy.sprite_, candy.loc_.x_, candy.loc_.y_);
  assert(! SSDL_SpriteHasIntersection(basket.sprite_, candy.sprite_));
  resetCandyPosition(candy);

  //We don't care about yumMessage position till we make one

  //And set velocities
  //basket's can't be specified till we check inputs
  enum { CANDY_SPEED = 11 };            //11 pixels per frame, straight down
  candy.velocity_.y_ = CANDY_SPEED;     //11 per frame straight down
  //Increase speeds for faster game
  yumMessage.velocity_ = { 1, -1 };     //Up and to the right

  //And rotational speeds
  candy.rotationSpeed_ = 1;             //Candy spins slightly
}

/////////////////////////// Drawing /////////////////////////////

//Display all 3 objects (2 if yumMessage is currently not visible)
void renderObjects (Object basket, Object candy, Object yumMessage,
                    bool showYumMessage)
{
  SSDL_RenderSprite (basket.sprite_); //also calls SSDL_RenderImageEx
  SSDL_RenderSprite ( candy.sprite_); 
  if (showYumMessage) SSDL_RenderSprite (yumMessage.sprite_);
}

void renderStats(int Caught, int Missed)
{
  //Stats boxes, for reporting how many candies caught and missed
  SSDL_SetRenderDrawColor(BLACK);
  enum { BOX_WIDTH = 90, BOX_HEIGHT = 25 };
  SSDL_RenderFillRect(0, 0,                        //Left box
		      BOX_WIDTH, BOX_HEIGHT);
  SSDL_RenderFillRect(SCREEN_WIDTH - BOX_WIDTH, 0, //Right box
		      SCREEN_WIDTH - 1, BOX_HEIGHT);

  //Statistics themselves
  SSDL_SetRenderDrawColor(WHITE);
  SSDL_SetFont(SMALL_FONT);						//Tests SetFont

  SSDL_SetCursor(0, 0);                           //Tests SetCursor
  sout << "Caught: " << Caught;                   //Tests sout

  SSDL_SetCursor(SCREEN_WIDTH - BOX_WIDTH, 0);     //Right box
  sout << "Missed: " << Missed;
}

//////////////// Moving objects in the world ///////////////////

void resetCandyPosition (Object& candy)  //When it's time to drop 
// another candy...
{
  //Put it at a random X location
  candy.loc_.x_ = MARGIN + rand() % (SCREEN_WIDTH - MARGIN); 
  candy.loc_.y_ = CANDY_START_HEIGHT;    //at the top of the screen

  SSDL_SetSpriteLocation(candy.sprite_, candy.loc_.x_, candy.loc_.y_);
}

void moveObject(Object& object)       
{
  object.loc_.x_ += object.velocity_.x_; //Every frame, move object
  object.loc_.y_ += object.velocity_.y_; //  as specified
  SSDL_SetSpriteLocation(object.sprite_, object.loc_.x_, object.loc_.y_);
  assert(SSDL_GetSpriteX(object.sprite_) == object.loc_.x_);
  assert(SSDL_GetSpriteY(object.sprite_) == object.loc_.y_);

  //...and spin as specified
  object.rotation_ += object.rotationSpeed_; 
  object.rotation_ %= 360;               //angle shouldn't go over 360
  SSDL_SetSpriteRotation(object.sprite_, object.rotation_);
  assert(SSDL_GetSpriteRotation(object.sprite_) == object.rotation_);
}

void moveBasket(Object& basket, int basketSpeed)
{
  //Let user move basket with left and right arrows
  if (SSDL_IsKeyPressed (SDLK_LEFT )) basket.loc_.x_ -= basketSpeed;  
  if (SSDL_IsKeyPressed (SDLK_RIGHT)) basket.loc_.x_ += basketSpeed;  

  //..but don't let the user touch the sides of the screen
  if (basket.loc_.x_ < MARGIN)
    basket.loc_.x_ = MARGIN;
  if (basket.loc_.x_ > SCREEN_WIDTH - MARGIN)
    basket.loc_.x_ = SCREEN_WIDTH - MARGIN;

  //Tell the sprite about our changes on X
  SSDL_SetSpriteLocation(basket.sprite_,
			 basket.loc_.x_, basket.loc_.y_);
}

////////What happens when a candy is caught or missed ////////

//Some math functions we need a lot...
int sqr(int num) { return num * num; }

double distance(Point2D a, Point2D b)
{
  return sqrt(sqr(b.x_ - a.x_) + sqr(b.y_ - a.y_));
}

//Circular collision detection, better for round-ish objects
bool inCollision(Point2D a, Point2D b, int aSize, int bSize)
{
  return (distance(a, b) < aSize/2 + bSize/2);
}

//Detect and handle collisions between basket and candy, 
// and update numberCaught
bool handleCatchingCandy (Object basket, Object& candy, Object& yumMessage,
                          int& numberCaught)
{
  if (inCollision (basket.loc_, candy.loc_, CANDY_WIDTH, BASKET_WIDTH))
    {
      SSDL_PlaySound(THUNK_SOUND); assert(SSDL_SoundPlaying(THUNK_SOUND));

      ++numberCaught;

      resetCandyPosition (candy);

      yumMessage.loc_.x_    = basket.loc_.x_;
      yumMessage.loc_.y_    = basket.loc_.y_;

      return true;
    }
  else return false;
}

//Detect and handle when candy goes off bottom of screen, 
// and update numberMissed
void handleMissingCandy (Object& candy, int& numberMissed)
{
  //you missed it: it went off screen
  if (candy.loc_.y_ >= SCREEN_HEIGHT)  
    {
      SSDL_PlaySound (DROP_SOUND); 

      ++numberMissed;

      resetCandyPosition (candy);
    }
}

///////////////////// Events /////////////////////

//Have not tested SSDL_DefaultEventHandler, but tested something close: the eventhandler in this program
void myEventHandler(bool& mouseClicked)
{
  SSDL_Event event;

  while (SSDL_PollEvent(event)) //test PollEvent
    switch (event.type)
      {
      case SDL_QUIT:            SSDL_DeclareQuit(); break; //test DeclareQuit
      case SDL_KEYDOWN:         if (SSDL_IsKeyPressed(SDLK_ESCAPE)) //test IsKeyPresse
	  SSDL_DeclareQuit(); 
	break;
      case SDL_MOUSEBUTTONDOWN: mouseClicked = true;
      }
}

///// ** The game itself ** ////

bool playGame ()
{
  bool isVictory          = false;      //Did we win?  Not yet
  bool isDefeat           = false;      //Did we lose? Not yet
  bool letsDisplayStats   = true;       //Do we show stats on screen?
  //  Yes, for now

  int numberCaught = 0,                 //So far no candies
    numberMissed = 0;                 //  caught or missed

  //Initialize sprites
  Object basket, candy, yumMessage;
  initializeObjects (basket, candy, yumMessage);

  SSDL_Color DARK_RED = SSDL_CreateColor(128, 0, 0, 64);
  const SSDL_Font TIMES = SSDL_OpenSystemFont("times", 24);
  SSDL_SetFont(TIMES); assert(SSDL_GetCurrentFont() == TIMES);

  //Here we can test whether memory is being destructed (use debugger)
  //Also testing using different valid font extensions
  SSDL_SetFont(SSDL_OpenSystemFont("times.ttf", 24));
#ifdef _WIN32
  SSDL_SetFont(SSDL_OpenSystemFont("times.TtF", 24)); //won't and shouldn't work on Unix, which is case sensitive
#endif

  SSDL_SetFramesPerSecond(50); 

  assert(!SSDL_SoundPlaying(THUNK_SOUND)); //of course it's not playing YET...
  //Main game loop
  while (SSDL_IsNextFrame () && ! isVictory && ! isDefeat) 
    {
      enum {FRAMES_FOR_YUM_MESSAGE = 60};
      static int framesLeftTillYumDisappears = 0;

      //Handle input events
      bool mouseClick = false; myEventHandler (mouseClick);
      if (mouseClick) letsDisplayStats = !letsDisplayStats;

      //Display the scene
      SSDL_RenderImage(BKGD_IMAGE, 0, 0); //test RenderImage
      SSDL_SetRenderDrawColor(DARK_RED);
      assert(SSDL_GetRenderDrawColor() == DARK_RED);
      SSDL_Color tempColor(DARK_RED); assert(DARK_RED == tempColor);
      tempColor = GREEN;              assert(GREEN == tempColor);

      SSDL_SetFont(TIMES); 
      SSDL_RenderTextCentered("This banner is centered and transparent dark red and in Times font", SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
      SSDL_SetRenderDrawColor(BLUE);
      SSDL_RenderText("But this is blue, left-justified, and in creepy font", 0, SCREEN_HEIGHT / 2 + 40, SMALL_FONT);

      renderObjects (basket, candy, yumMessage,
		     framesLeftTillYumDisappears>0);
      if (letsDisplayStats) renderStats (numberCaught, numberMissed);

      //Updates:

      //Move objects in the scene
      enum { BASKET_SPEED = 7 };    //7 pixels per frame, left or right
      moveBasket(basket, BASKET_SPEED);
      moveObject(candy); moveObject(yumMessage);

      //Did you catch a candy?
      if (handleCatchingCandy(basket, candy, yumMessage, numberCaught))
	framesLeftTillYumDisappears = FRAMES_FOR_YUM_MESSAGE;

      if (numberCaught >= MAX_CAUGHT) 
	isVictory = true; 
      else                                  //...or did it go off screen?
        {
	  handleMissingCandy (candy, numberMissed);
	  if (numberMissed >= MAX_MISSED) 
	    isDefeat = true; //You just lost!
        }

      //Update yum message
      if (framesLeftTillYumDisappears > 0)  //if yumMessage is active
	--framesLeftTillYumDisappears;    //  keep counting down
    }

  return isVictory;
}
