#include <cmath> //for sqrt
#include <sstream>
#include <cstring> //for strcmp
#include <string>
#include <SDL.h>
#include <exception>
#include <cstring> 
#include <SDL_ttf.h>
//#include <SDL_image.h>


#include "SSDL_color.h"

using namespace std;

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), GREEN (0, 255, 0);

#include "SSDL_exception.h"

void SSDL_terminate() //DOES NOT GET CALLED when we are in the Debugger
{
    abort();
}



#include "SSDL_display.h"
//#include "SSDL_font.h"
#include "SSDL_sound.h"
#include "SSDL_io.h"
#include "SSDL_stream.h"

static bool isEscapeMeansQuit = true;

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{
    return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
    if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
    if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
        && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
        SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
    SSDL_RenderPresent();

    while (!SSDL_Display::Instance().isTimeToQuit())
    {
        if (SDL_WaitEvent(&sdlEvent) == 0) throw SSDL_Exception();
        SSDL_CheckForQuitMessages(sdlEvent);
        if (sdlEvent.type == eventType) return;
    }
}

void SSDL_DefaultEventHandler()
{
    SSDL_Event event;

    while (SSDL_PollEvent(event))
        switch (event.type)
        {
        case SDL_QUIT:    SSDL_DeclareQuit(); break;
        case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();
        case SDL_WINDOWEVENT_MAXIMIZED:
        case SDL_WINDOWEVENT_RESTORED:    
        case SDL_WINDOWEVENT_SIZE_CHANGED:
        case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
            break;
        }
}

int  SSDL_WaitMouse()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
    return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_KEYDOWN, event);
    return event.key.keysym.sym;
}

  //This is the SSDL_Display -- the screen you see when the program runs. 

//#include "SSDL_image.h"
#include "SSDL_font.h"

#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#define FEDORA_FONT_PATH "/usr/share/fonts/msttcore/"
#define OPENSUSE_FONT_PATH "/usr/share/fonts/truetype/"
#define OPENSUSE_FONT_PATH_NEW "/usr/share/fonts/msttcorefonts/"
#define MANJARO_FONT_PATH "/usr/share/fonts/TTF"

SSDL_Display::SSDL_Display() : isTimeToQuit_(false)
{
    std::set_terminate(SSDL_terminate);

    if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
        throw SSDL_Exception();


    sdlWindow_ = SDL_CreateWindow("",              //no title by default
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        DEFAULT_WIDTH, DEFAULT_HEIGHT,
        0);           //flags are 0 by default
    if (!sdlWindow_) throw SSDL_Exception();

    //defaults below:  index shd be -1 (pick the first renderer that works best)
    //rendererFlags should be 0
    int rendererIndex = -1;
    int rendererFlags = 0;
    sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

    if (!sdlRenderer_) throw SSDL_Exception();

    SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

    SDL_ClearError();
    
    static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
    if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw SSDL_Exception();

    if (TTF_Init() == -1) throw SSDL_Exception();

    SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);

    int point = 14;
    std::string filename = "arial.ttf"; 
    std::string finalFilename;

#ifdef _WIN32
    systemFontPath_ = WINDOWS_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
#else //Unix
    systemFontPath_ = UBUNTU_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    if (!currentFont_) //OK, if it's not on the UBUNTU path, is it in the FEDORA path?
    {
        finalFilename = SSDL_SystemFontPath(FEDORA_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = FEDORA_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the OPENSUSE path?
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the new OPENSUSE path? I find different paths for different installs of msttcore-fonts
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH_NEW, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH_NEW;
    }
    if (!currentFont_)  //If not, is it in the MANJARO path?
    {
        finalFilename = SSDL_SystemFontPath(MANJARO_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = MANJARO_FONT_PATH;
    }
#endif

    if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Missing ") + filename +
            ". Either msttcore fonts aren't installed or the path to them is unknown.\n"
            "If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";

        setCrashMessage(errorMsg); 
        throw SSDL_Exception(errorMsg.c_str());
    }

    TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
}

TTF_Font* SSDL_GetCurrentFont()
{
    return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
    SSDL_Display::Instance().setCurrentFont(newFont);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
    strcpy(temp, str);

    char* nextLine = strtok(temp, "\n\r");
    while (nextLine)
    {
        RenderTextLine(nextLine, x, y, font, isCentered);
        y += fontLineSkip();
        nextLine = strtok(NULL, "\n\r");
    }
    delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    SDL_Surface* surfaceToPrintOn;
    surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
    //arg -- having to cast away that const again.  Why should I have to?
    //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
    //I can fix this with my own calls
    if (!surfaceToPrintOn) throw SSDL_Exception();


    SDL_Texture* textureToPrint;
    textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

    if (!textureToPrint) throw SSDL_Exception();

    int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
    SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

    if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
        throw SSDL_Exception();
    //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
    //Another time perhaps
    SDL_DestroyTexture(textureToPrint);
    SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
    return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}


void SSDL_RenderClear(const SSDL_Color& c)
{
    SSDL_Color old = SSDL_GetRenderDrawColor();
    SSDL_SetRenderDrawColor(c);
    SSDL_RenderClearAux();
    SSDL_SetRenderDrawColor(old);
}

void SSDL_Display::setWindowSize(int w, int h)
{
#ifdef __unix__
    SDL_Event e; while (SDL_PollEvent(&e));
#endif
    //In Unix sometimes if I don't to this, the
    //next call to SDL_GetWindowSize will get the old
    //dimensions, not the new. Go figure.

    SDL_SetWindowSize(SSDL_Display::Instance(), w, h);

#ifdef __unix__
    SDL_RenderPresent(SSDL_Display::Instance());
    for (int i = 0; i < 40; ++i) //Must be 6 or more to be reliable
        SDL_Delay(30);          //10 works; 1 doesn't
      //A single SDL_Delay(60); usually works
      //but sometimes does not
      //The current numbers 40x30, are there to make it work with OpenSuSe. Would like to have
      // a more rational long-term fix. Maybe SDL.org will have one by now.
#endif
}

  //This is SSDL_Font, a wrapper for TTF_Font

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
    std::string newPath(fontPath); newPath += filename;
    if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
    return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
    string finalFilename;
    TTF_Font* currentFont_; //WSB: change to "result"

//      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "systemFontPath_", SSDL_Display::Instance().systemFontPath(), NULL);
    finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "final filename", finalFilename.c_str(), NULL);

    if (!currentFont_) 
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); 
        throw SSDL_Exception();
    }
    return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
    char* strEnd = (char*)str + strlen(str) - 1;
    char* substrEnd = (char*)substr + strlen(substr) - 1;

    for (;; --strEnd, --substrEnd)
    {
        if (toupper(*substrEnd) != toupper(*strEnd))  return false;

        if (substrEnd <= substr)    return true;
        else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
    SSDL_Display::Instance(); 

    string finalFilename = filename;
    if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

    TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
    if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); 
        throw SSDL_Exception();
    }
    return result;
}

//
//#include <string>
//#include <SDL_image.h>
//#include "SSDL_display.h"
//#include "SSDL_sound.h"
#include "SSDL_singletonManager.h"

void atexitHandler();

class SSDL_SingletonManager
{
public:
    SSDL_SingletonManager()
    {
        atexit(atexitHandler);
        SSDL_Display::Instance();
        //SSDL_SoundSystem::Instance();
    }
    std::string crashMessage;
};

static SSDL_SingletonManager singletonManagerInstance;

void setCrashMessage(const std::string& msg) { singletonManagerInstance.crashMessage = msg; }

void atexitHandler()
{
    if (singletonManagerInstance.crashMessage.length()) //if there was a crash message...display it
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", singletonManagerInstance.crashMessage.c_str(), NULL);

}


//This is the Sound System.  It provides. all access to sounds.

//#include "SSDL_sound.h"

//SSDL SoundSystem
SSDL_SoundSystem::SSDL_SoundSystem(int freq, Uint16 format, int channels, int chunkSize)
{
    initializedOK_ = (Mix_OpenAudio(freq, format, channels, chunkSize) != -1); //8-7-2017
    if (!initializedOK_) SDL_ClearError(); //or we'll get this complaint later, when it makes no sense
}

Mix_Music* SSDL_Music::music_ = NULL;


#include "SSDL_timer.h"

static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
    SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
    //	SDL_Rect rect = {0, 0, 1, 1};

        //erase that last char by replacing with background color
    SDL_Rect newRect;
    newRect.x = cursorX(); newRect.y = cursorY();
    newRect.w = SSDL_Display::Instance().advance(c);
    newRect.h = SSDL_Display::Instance().fontLineSkip();
    Uint8 r, g, b, a;
    SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
    SSDL_Color background_ = SSDL_Display::Instance().background();
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
    SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
    SSDL_RenderPresent();

    SDL_FreeSurface(result);
}


class SSDL_Timer
{
public:
    static SSDL_Timer& Instance()
    {
        static SSDL_Timer myInstance;
        return myInstance;
    }

    SSDL_Timer(const SSDL_Timer&) = delete;
    const SSDL_Timer& operator= (const SSDL_Timer&) = delete;

    void setFramesPerSecond(Uint32 fps) { frameDuration_ = 1000 / fps; }
    //maybe I shd just do frame duration as 1/60 of a second?
    bool sync();
private:
    SSDL_Timer() : timeAtNextFrame_(0)
    {
        setFramesPerSecond(60);	//default to 60 frames per second.
    }

    Uint32 frameDuration_;		//in milliseconds
    Uint32 timeAtNextFrame_;	//in milliseconds, counting from time we started SDL
};

// Frame Per Second Function  , put this in a loop
bool SSDL_Timer::sync()
{
    if (SSDL_Display::Instance().isTimeToQuit()) return false;

    SSDL_RenderPresent();

    Uint32 currentTime = SDL_GetTicks();
    if (timeAtNextFrame_ > currentTime)
        SDL_Delay(timeAtNextFrame_ - currentTime);

    timeAtNextFrame_ = currentTime + frameDuration_;

    return true;
}

bool SSDL_IsQuitMessage()
{
    SSDL_DefaultEventHandler();
    return !SSDL_IsNextFrame();
}

void SSDL_SetFramesPerSecond(Uint32 FPS) { SSDL_Timer::Instance().setFramesPerSecond(FPS); }
bool SSDL_IsNextFrame() { return SSDL_Timer::Instance().sync(); }

int main (int argc, char** argv)
{
  //SSDL_SetWindowSize  (640, 480);
  //SSDL_WaitMouse();

  //Test drawing, SSDL_ToggleEscapeIsQuit, RenderClear using erase color
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();

  std::string str;  ssin >> str;

  return 0;
}
