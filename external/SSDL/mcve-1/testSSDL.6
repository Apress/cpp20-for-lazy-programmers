#include <cmath> //for sqrt
#include <sstream>
#include <cstring> //for strcmp
#include "SSDL_display.h"
#include "SSDL_image.h"
#include "SSDL_font.h"
#include "SSDL_sound.h"
#include "SSDL_timer.h"
#include "SSDL_io.h"
#include "SSDL_stream.h"
#include "SSDL_sprite.h"
#include "SSDL_draw.h"
#include "SSDL_color.h"

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);


#include <SDL.h>
#include "SSDL_exception.h"

void SSDL_terminate() //DOES NOT GET CALLED when we are in the Debugger
{
    try
    {
        throw;
    }
    catch (const SSDL_Exception& c)
    {
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", c, NULL); 
    }

    abort();
}



/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //Various functions related to I/O (mouse or keyboard)

#include <SDL.h>
#include "SSDL.h" //for refreshDisplay

static bool isEscapeMeansQuit = true; //make this something that starts with "SSDL_"
//static bool isVisible = true;        
void SSDL_ToggleEscapeMeansQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{	//The !=0 at the end is to suppress a coercion from Uint8 to bool warning
    //SDL_GetScancodeFromKey:  SDL_GetKeyboardState returns an array that'll tell you
    // what scancodes are currently pressed.  We want to know which keys.  So we must
    // convert
    return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
    if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
    if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
        && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
        SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
    //if (isVisible) 
    SSDL_RenderPresent();
    //Why this?  because it's annoying to have the screen not update while you're
    //waiting for an event!

    while (!SSDL_Display::Instance().isTimeToQuit())
    {
        if (SDL_WaitEvent(&sdlEvent) == 0) throw SSDL_Exception();
        SSDL_CheckForQuitMessages(sdlEvent);
        if (sdlEvent.type == eventType) return;
    }
}

void SSDL_ToggleEscapeIsQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

void SSDL_DefaultEventHandler()
{
    SSDL_Event event;

    while (SSDL_PollEvent(event))
        switch (event.type)
        {
        case SDL_QUIT:    SSDL_DeclareQuit(); break;
        case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();

            //The rest of these you should probably leave alone.
                //First: if the window is minimized, make a note we don't need to draw it until it isn't
            //case SDL_WINDOWEVENT_MINIMIZED:    isVisible = false; break;

                //Second: if it stopped being minimized, make a note we DO need to draw it
        case SDL_WINDOWEVENT_MAXIMIZED:
        case SDL_WINDOWEVENT_RESTORED:     //isVisible = true; 

            //...and if it was just made visible, or was obscured and is now less so, or
            //  was resized, do an immediate update
        case SDL_WINDOWEVENT_SIZE_CHANGED:
        case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
            break;
        }
}

int  SSDL_WaitMouse()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
    return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_KEYDOWN, event);
    return event.key.keysym.sym;
}


#include <SDL.h>
#include "SSDL_display.h"
#include "SSDL_image.h"

SSDL_Image SSDL_LoadImage(const char* filename)
{
    SSDL_Display::Instance(); //be sure SDL is initialized before calling IMG_Load

    SDL_Surface* sdlSurface = IMG_Load(filename);
    if (!sdlSurface) throw SSDL_Exception();

    SDL_Texture* result = SDL_CreateTextureFromSurface(SSDL_Display::Instance(), sdlSurface);
    if (!result) throw SSDL_Exception(); //sure would be nice if we could convey what
    //file failed!
    SDL_FreeSurface(sdlSurface);

    return SSDL_Image(result);
}

/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
  claim that you wrote the original software. If you use this software
  in a product, an acknowledgment in the product documentation would be
  appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
  misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is the SSDL_Display -- the screen you see when the program runs. 

#include <exception>
#include <cstring> 
#include <SDL.h>
#include <SDL_ttf.h>
#include <SDL_image.h>
#include "SSDL_display.h"
#include "SSDL_image.h"
#include "SSDL_font.h"

#ifdef _MSC_VER                                 //If it's Visual Studio
#pragma warning(disable : 4996) //Disable the "feature" that makes strcpy an error!
#endif

#define WINDOWS_FONT_PATH "C:\\Windows\\Fonts\\"
#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#define FEDORA_FONT_PATH "/usr/share/fonts/msttcore/"
#define OPENSUSE_FONT_PATH "/usr/share/fonts/truetype/"
#define OPENSUSE_FONT_PATH_NEW "/usr/share/fonts/msttcorefonts/"
#define MANJARO_FONT_PATH "/usr/share/fonts/TTF"

//What's this crazy stuff here?  I need to ensure that SSDL_Display::Instance()
// is called (thus initializing SDL among other things) before main starts.
//This will do it.  Why do I care?  In case someone does something in main
// with an SDL feature like mouse cursor that I am not supporting.  It won't
// work till SDL is initialized.  Now it is.

//Weakness:  what if they do this SDL feature globally?  Then order of initialization
// is not guaranteed by C++.  But if they know enough to use an SDL feature, they
// should know enough not to do things with it before SDL is initialized.  So there.

//Will Briggs, 11-12-2015

SSDL_Display::SSDL_Display() : //background_ (0, 0, 0, 255), foreground_ (255, 255, 255, 255),
    isTimeToQuit_(false)
{
    std::set_terminate(SSDL_terminate);

    if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
        throw SSDL_Exception();


    sdlWindow_ = SDL_CreateWindow("",              //no title by default
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        DEFAULT_WIDTH, DEFAULT_HEIGHT,
        0);           //flags are 0 by default
    if (!sdlWindow_) throw SSDL_Exception();

    //defaults below:  index shd be -1 (pick the first renderer that works best)
    //rendererFlags should be 0
    int rendererIndex = -1;
    int rendererFlags = 0;
    sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

    if (!sdlRenderer_) throw SSDL_Exception();

    //sdlSurface_ = SDL_GetWindowSurface(sdlWindow_); //WSB: It would be polite to free this later

    //if (! sdlSurface_ ) throw SSDL_Exception ();

    //Some distros Unix, sometimes, don't start with a blank screen. Make them. 2021-06-08
    SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

    SDL_ClearError(); //Why? SDL2_Image documentation warns that IMG_Init does not necessarily
    // set the Error, so I figure I'd better clear it.  I hope it sets it if there's an error!
    static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
    if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw SSDL_Exception();

    if (TTF_Init() == -1) throw SSDL_Exception();

    //Had to avoid calling SSDL_SetRenderDrawColor because it calls SSDL_Display::Instance
    //which calls this ctor, and a thread-safe mechanism got this thing stuck waiting forever
    SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);//the default color for drawing is WHITE.  I don't use the constant
    //because I don't _know_ that it's been initialized yet.

    int point = 14;
    std::string filename = "arial.ttf"; //This default is recorded in C++20 for Lazy Programmers, so DON'T CHANGE
    std::string finalFilename;

#ifdef _WIN32
    systemFontPath_ = WINDOWS_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
#else //Unix
    systemFontPath_ = UBUNTU_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    if (!currentFont_) //OK, if it's not on the UBUNTU path, is it in the FEDORA path?
    {
        finalFilename = SSDL_SystemFontPath(FEDORA_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = FEDORA_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the OPENSUSE path?
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the new OPENSUSE path? I find different paths for different installs of msttcore-fonts
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH_NEW, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH_NEW;
    }
    if (!currentFont_)  //If not, is it in the MANJARO path?
    {
        finalFilename = SSDL_SystemFontPath(MANJARO_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = MANJARO_FONT_PATH;
    }
#endif

    if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Missing ") + filename +
            ". Either msttcore fonts aren't installed or the path to them is unknown.\n"
            "If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";
        //Look up a few lines for how to add your own fonts path.

        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
        //VS in debugger crashes (good) and shows you where (good) but doesn't
        // call the function specified in set_terminate (bad)
        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception(errorMsg.c_str());
    }

    TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
    //This should be done as soon as the error condition arises.  Can we make this happen?  I think so -- by
    // rigorously checking return values, from (for example) SDL_DestroyTexture.  But this would require extra code after
    // any particular call, and that seems costly.

    //const char* errorString = SDL_GetError ();
    //8-17-2017
    //In Windows 10, if there is no speaker connected, you get a new sound system error every time
    // you try to do something iwth a sound -- it won't just let it go
    //So for now, I won't let errors get reported.  This is not optimal.
    //if (errorString[0] != '\0') //if there's an error
    //                      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "SDL Error", SDL_GetError (), NULL);

    /*
      5-20-2020 MinGW never returns to the command prompt because of SDL_Quit, which undoubtedly relates
      to the unspecified order of constructing/destructing globals between files. Ergo: for now
      just don't do it. Fix later.
      TTF_Quit();
      IMG_Quit();
      //SDL_DestroyRenderer (sdlRenderer_); //not needed, but OK //It was noticeably causing delay, so I commented it out
      SDL_DestroyWindow(sdlWindow_); //not needed, but OK
      SDL_Quit ();
    */
}

TTF_Font* SSDL_GetCurrentFont()
{
    return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
    SSDL_Display::Instance().setCurrentFont(newFont);
}


void SSDL_RenderImage(SDL_Texture* image, int x, int y, int stretchWidth, int stretchHeight)
{
    SDL_Rect dst; //src is dimensions of image; dst is where it's goin on screen
    dst.x = x; dst.y = y;

    if (stretchWidth == 0 || stretchHeight == 0) //what if they put in 0 for either?  then dont' stretch
        SDL_QueryTexture(image, NULL, NULL, &dst.w, &dst.h); //get width and height of image
    else
    {
        dst.w = stretchWidth; dst.h = stretchHeight;
    }

    SDL_RenderCopy(SSDL_Display::Instance(), image, NULL, &dst);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
//It's possible that the str may contain \n or \r.  If so, it should be broken into lines
// and printed.  If centered, we need to remember the center point.  If not, we need to remember the starting point
{
    //This is all about splitting str by using strtok
    // Because std::string doesn't support this, I must do my own dynamic memory

    char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
    strcpy(temp, str);

    char* nextLine = strtok(temp, "\n\r");
    while (nextLine)
    {
        RenderTextLine(nextLine, x, y, font, isCentered);
        y += fontLineSkip();
        nextLine = strtok(NULL, "\n\r");
    }
    delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    SDL_Surface* surfaceToPrintOn;
    surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
    //arg -- having to cast away that const again.  Why should I have to?
    //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
    //I can fix this with my own calls
    if (!surfaceToPrintOn) throw SSDL_Exception();


    SDL_Texture* textureToPrint;
    textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

    if (!textureToPrint) throw SSDL_Exception();

    int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
    SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

    if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
        throw SSDL_Exception();
    //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
    //Another time perhaps
    SDL_DestroyTexture(textureToPrint);
    SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
    return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}


/*void SSDL_Display::scrollVertically (unsigned int pixels) //Not currently done; maybe nice in next version
  {
  SDL_Rect srcRect, destRec;
  srcRect.x = destRec.x = 0;
  srcRect.y = pixels;
  destRec.y= 0;
  srcRect.w = destRec.w = sdlSurface_->w; //If I need sdlSurface_, get it at last minute with SDL_GetWindowSurface
  srcRect.h = destRec.h = sdlSurface_->h - pixels;

  SDL_Surface* temp = SSDL_CopySurface (sdlSurface_);
  //SDL_FillRect (temp, &srcRect, SDL_MapRGB (sdlSurface_->format, 255, 255, 255));
  //I don't know if you can copy a surface onto itself...
  SDL_BlitSurface (temp, NULL, sdlSurface_, NULL);
  //SDL_BlitSurface (temp, &srcRect, sdlSurface_, &destRec); //I think it's not blitting -- I think the
  //then a bkgd-color rectangle at the bottom
  }
*/
void SSDL_RenderClear(const SSDL_Color& c)
{
    SSDL_Color old = SSDL_GetRenderDrawColor();
    SSDL_SetRenderDrawColor(c);
    SSDL_RenderClearAux();
    SSDL_SetRenderDrawColor(old);
}

void SSDL_Display::setWindowSize(int w, int h)
{
#ifdef __unix__
    SDL_Event e; while (SDL_PollEvent(&e));
#endif
    //In Unix sometimes if I don't to this, the
    //next call to SDL_GetWindowSize will get the old
    //dimensions, not the new. Go figure.

    SDL_SetWindowSize(SSDL_Display::Instance(), w, h);

#ifdef __unix__
    SDL_RenderPresent(SSDL_Display::Instance());
    for (int i = 0; i < 40; ++i) //Must be 6 or more to be reliable
        SDL_Delay(30);          //10 works; 1 doesn't
      //A single SDL_Delay(60); usually works
      //but sometimes does not
      //The current numbers 40x30, are there to make it work with OpenSuSe. Would like to have
      // a more rational long-term fix. Maybe SDL.org will have one by now.
#endif

  //Programs in the repository that fail on some unix installations unless I do this
  // are Ch2/[any but sound], ch4/search*, ch9/*, ch10/ticTacToeBoard, ch11/staircase

  //The earlier SDL_Event e;... line is also needed for ch11/spritefish* and possibly
  // for other programs with game loops
  //#elif __unix__
  //...
  //#endif
}


/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is a collection of functions for drawing shapes.

#include <cmath> 
#include "SSDL_draw.h"

#define PI 3.14159

//http://content.gpwiki.org/index.php/SDL:Tutorials:Drawing_and_Filling_Circles has another method
//it may look better but it's incomprehensible

void SSDL_RenderFillCircle(int xc, int yc, int radius)
{
    for (int dy = -radius; dy <= radius; ++dy)
    {
        //x^2 + y^2 = r^2, so x = sqrt (r^2 - y^2)
        int dx = int(sqrt(radius * radius - dy * dy) + 0.5);
        SSDL_RenderDrawLine(xc - dx, yc + dy, xc + dx, yc + dy);
    }
}

void SSDL_RenderDrawCircle(int xc, int yc, int radius)
{
    //What angleIncrement should we use?  one that subtends about a pixel
    //sin(angleIncrement) = 1 / radius
    double angleIncrement = asin(1.0 / radius);

    for (double angle = 0; angle <= 2 * PI; angle += angleIncrement)
    {
        int y = int(radius * sin(angle) + 0.5);
        int x = int(radius * cos(angle) + 0.5);
        SSDL_RenderDrawPoint(xc + x, yc + y);
    }
}

void SSDL_RenderDrawCircles(SSDL_Circle* circles, int count)
{
    for (int i = 0; i < count; ++i)
        SSDL_RenderDrawCircle(circles[i].x, circles[i].y, circles[i].radius);
}

void SSDL_RenderFillCircles(SSDL_Circle* circles, int count)
{
    for (int i = 0; i < count; ++i)
        SSDL_RenderFillCircle(circles[i].x, circles[i].y, circles[i].radius);
}


/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

  //This is SSDL_Font, a wrapper for TTF_Font

#include <string>
#include <cstring>
#include <sstream>
#include "SSDL_font.h"
#include "SSDL_exception.h"
#include "SSDL_display.h"

using namespace std;

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
    std::string newPath(fontPath); newPath += filename;
    if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
    return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
    string finalFilename;
    TTF_Font* currentFont_; //WSB: change to "result"

//      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "systemFontPath_", SSDL_Display::Instance().systemFontPath(), NULL);
    finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "final filename", finalFilename.c_str(), NULL);

    if (!currentFont_) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
                                                        //VS in debugger crashes (good) and shows you where (good) but doesn't
                                                        // call the function specified in set_terminate (bad)
                                                        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception();
    }
    return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
    char* strEnd = (char*)str + strlen(str) - 1;
    char* substrEnd = (char*)substr + strlen(substr) - 1;

    for (;; --strEnd, --substrEnd)
    {
        if (toupper(*substrEnd) != toupper(*strEnd))  return false;

        if (substrEnd <= substr)    return true;
        else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
    SSDL_Display::Instance(); //be sure SSDL is initialized...

    //We hope the filename ends in .ttf.  If not, and there's no extension, append it.
    //If not, and there is an (incorrect) extension, go ahead and append it, and watch it fail.

    string finalFilename = filename;
    if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

    TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
    if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
                                                        //VS in debugger crashes (good) and shows you where (good) but doesn't
                                                        // call the function specified in set_terminate (bad)
                                                        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception();
    }
    return result;
}


#include <string>
#include <SDL_image.h>
#include "SSDL_display.h"
#include "SSDL_sound.h"
#include "SSDL_singletonManager.h"

void atexitHandler();

class SSDL_SingletonManager
{
public:
    SSDL_SingletonManager()
    {
        atexit(atexitHandler);
        SSDL_Display::Instance();
        SSDL_SoundSystem::Instance();
    }
    std::string crashMessage;
};

static SSDL_SingletonManager singletonManagerInstance;

void setCrashMessage(const std::string& msg) { singletonManagerInstance.crashMessage = msg; }

void atexitHandler()
{
    if (singletonManagerInstance.crashMessage.length()) //if there was a crash message...display it
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", singletonManagerInstance.crashMessage.c_str(), NULL);

}


//This is the Sound System.  It provides. all access to sounds.

#include "SSDL_exception.h"
#include "SSDL_sound.h"

//SSDL SoundSystem
SSDL_SoundSystem::SSDL_SoundSystem(int freq, Uint16 format, int channels, int chunkSize)
{
    //Start SDL2_Mixer. Apparently you don't really need to...
    //int soundsSupported = Mix_Init(MIX_INIT_FLAC | MIX_INIT_MOD | MIX_INIT_MP3 | MIX_INIT_OGG);
    //if (!soundsSupported) throw SSDL_Exception();

    initializedOK_ = (Mix_OpenAudio(freq, format, channels, chunkSize) != -1); //8-7-2017
    if (!initializedOK_) SDL_ClearError(); //or we'll get this complaint later, when it makes no sense
    //I commented out all refs to throwing SSDL_Exception in SSDL_sound.*, so we could get by with this
    //It may not be the best solution.
    //Fix later.  8-7-2017

    //if (Mix_OpenAudio(freq, format, channels, chunkSize) == -1)
    //		throw SSDL_Exception (); 
}

Mix_Music* SSDL_Music::music_ = NULL;

void SSDL_PlaySound(const SSDL_Sound& sound, int repeats)
{
    int result = Mix_PlayChannel(sound, sound, repeats);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_FadeInSound(SSDL_Sound& sound, int repeats, int ms)
{
    int result = Mix_FadeInChannel(sound, sound, repeats, ms);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_PlaySoundTimed(SSDL_Sound& sound, int repeats, int ticks)
{
    int result = Mix_PlayChannelTimed(sound, sound, repeats, ticks);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_FadeInSoundTimed(SSDL_Sound& sound, int repeats, int ms, int ticks)
{
    int result = Mix_FadeInChannelTimed(sound, sound, repeats, ms, ticks);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

//Timer-related functions.

//#include "SSDL_color.h"
//#include "SSDL_display.h"
#include "SSDL_timer.h"
//#include "SSDL.h"

//#include "SSDL_display.h"
//#include "SSDL_stream.h"
//#include "SSDL_io.h"

//using namespace std;

static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
    SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
    //	SDL_Rect rect = {0, 0, 1, 1};

        //erase that last char by replacing with background color
    SDL_Rect newRect;
    newRect.x = cursorX(); newRect.y = cursorY();
    newRect.w = SSDL_Display::Instance().advance(c);
    newRect.h = SSDL_Display::Instance().fontLineSkip();
    Uint8 r, g, b, a;
    SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
    SSDL_Color background_ = SSDL_Display::Instance().background();
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
    SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
    SSDL_RenderPresent();

    SDL_FreeSurface(result);
}


class SSDL_Timer
{
public:
    static SSDL_Timer& Instance()
    {
        static SSDL_Timer myInstance;
        return myInstance;
    }

    SSDL_Timer(const SSDL_Timer&) = delete;
    const SSDL_Timer& operator= (const SSDL_Timer&) = delete;

    void setFramesPerSecond(Uint32 fps) { frameDuration_ = 1000 / fps; }
    //maybe I shd just do frame duration as 1/60 of a second?
    bool sync();
private:
    SSDL_Timer() : timeAtNextFrame_(0)
    {
        setFramesPerSecond(60);	//default to 60 frames per second.
    }

    Uint32 frameDuration_;		//in milliseconds
    Uint32 timeAtNextFrame_;	//in milliseconds, counting from time we started SDL
};

// Frame Per Second Function  , put this in a loop
bool SSDL_Timer::sync()
{
    if (SSDL_Display::Instance().isTimeToQuit()) return false;

    SSDL_RenderPresent();

    //SDL_GetTicks returns current time (since SDL was initialized)
    //if the time at the next frame is later than that, wait.  How long?  The difference
    Uint32 currentTime = SDL_GetTicks();
    if (timeAtNextFrame_ > currentTime)
        SDL_Delay(timeAtNextFrame_ - currentTime);

    //Now set the time at the next frame to the current time, plus the duration of one frame
    timeAtNextFrame_ = currentTime + frameDuration_;

    return true;
}

bool SSDL_IsQuitMessage()
{
    SSDL_DefaultEventHandler();
    return !SSDL_IsNextFrame();
}

void SSDL_SetFramesPerSecond(Uint32 FPS) { SSDL_Timer::Instance().setFramesPerSecond(FPS); }
bool SSDL_IsNextFrame() { return SSDL_Timer::Instance().sync(); }


enum {SCREEN_WIDTH=675, SCREEN_HEIGHT=522}; //dimensions of bkgd

int main (int argc, char** argv)
{
  //Test window functions
  SSDL_SetWindowTitle ("Window should be in top left corner of screen");
  assert(!strcmp(SSDL_GetWindowTitle(), "Window should be in top left corner of screen"));
  SSDL_SetWindowPosition(100, 100);
  int x, y; SSDL_GetWindowPosition(x, y); assert(x == 100); assert(y == 100);
  SSDL_SetWindowSize  (SCREEN_WIDTH, SCREEN_HEIGHT);
  assert(SSDL_GetWindowWidth() == SCREEN_WIDTH); assert(SSDL_GetWindowHeight() == SCREEN_HEIGHT);
  SSDL_SetWindowPosition(5, 5);

  //Test GetMouse*: click, x, y; SSDL_IsQuit; SSDL_ToggleEscapeIsQuit
  assert(!SSDL_IsQuit());         //Too hard to test when it succeeds! But it's simple enough I'll let that go.
  SSDL_ToggleEscapeIsQuit();
  SSDL_SetCursor(0,0);
  sout << "Click mouse. Escape won't kill the program on this screen!\n";
  SSDL_WaitMouse();
  switch (SSDL_GetMouseClick())
    {
    case SDL_BUTTON_LEFT: sout << "Left button clicked.\n"; break;
    case SDL_BUTTON_RIGHT:sout << "Right button clicked.\n"; break;
    default: sout << "Unknown button clicked -- not left or right!\n";
    }
  sout << "You clicked at point (" << SSDL_GetMouseX() << ", " << SSDL_GetMouseY() << "). Click again!\n";
  SSDL_WaitMouse();

  //Test drawing, SSDL_ToggleEscapeIsQuit, RenderClear using erase color
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();

  SSDL_SetRenderDrawColor(WHITE);	SSDL_RenderFillCircle(100, 300, 49);
  SSDL_SetRenderDrawColor(RED);   SSDL_RenderDrawCircle(100, 300, 50);
  SSDL_RenderDrawPoint(100, 400);

  SSDL_SetRenderDrawColor(WHITE);	SSDL_RenderFillRect(200, 300, 90, 90);
  SSDL_SetRenderDrawColor(RED);   SSDL_RenderDrawRect(200, 300, 90, 90);
  SSDL_RenderDrawPoint(245, 345);

  SDL_Point points[5] = { {300,300},{390,300},{390,390},{300,390},{300,300} };

  SSDL_RenderDrawLines(points, 5);
  SDL_Rect rects[3] = { {300,300,30,20},{330,335,30,20},{360,370,30,20} };
  SSDL_SetRenderDrawColor(WHITE); SSDL_RenderFillRects(rects, 3);
  SSDL_SetRenderDrawColor(RED); SSDL_RenderDrawRects(rects, 3);
  SSDL_RenderDrawLine(0, 450, SCREEN_WIDTH, 450);

  SSDL_SetRenderDrawColor(WHITE);
  SDL_Rect rect = { 400,300,90,90 };
  SDL_Point measles[] = { {410,310},{450,350},{490,390} };
  SSDL_RenderDrawRect(rect);
  SSDL_RenderDrawPoints(measles, 3);

  //Test erase color, pause/resume music
  std::string str;

  SSDL_SetCursor(0, 0);
  sout << "Window is near upper left of screen.\n";
  sout << "Check out these figures : bordered circles and rects.\n";
  sout << "Default font, GREEN background.\n";
  sout << "Enter text. Backspace to see BLUE\n"; 
  sout << "Hit Esc all you want, until you enter the text.\n";

  SSDL_SetRenderEraseColor(BLUE);
  assert(SSDL_GetRenderEraseColor() == BLUE);
  ssin >> str;

  return 0;
}
