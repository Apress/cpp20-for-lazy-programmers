#include <cmath> //for sqrt
#include <sstream>
#include <cstring> //for strcmp
#include <string>
#include <SDL.h>
#include <exception>
#include <cstring> 
#include <SDL_ttf.h>
#include "SSDL_color.h"

using namespace std;

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), GREEN (0, 255, 0);

#include "SSDL_exception.h"

void SSDL_terminate() //DOES NOT GET CALLED when we are in the Debugger
{
    abort();
}



#include "SSDL_display.h"
//SSDL_stream.h stuff

//#include <iostream>
#include <cassert>
//#include <cstring> //for memmove
#include "SSDL_font.h"
#include "SSDL_io.h"
#include "SSDL_image.h"

//extern SSDL_Font* currentFont; //move to SSDL_font, and make it generally avaiable?

//SDL has a cursor, but that's for mouse.
//I need one for my stream IO.
//I will make it as a square, based on font size, with a line at the bottom.
//It will be drawn to cursorX, cursorY location
//Backspace should move it back, leaving behind an empty box (use SSDL_Display background color)
//When we put text there, make sure to erase it!

//scrolling will be triggered when cursorY() gets to within fontLineSkip*2 pixels of the bottom of the screen.
//It will capture the screen, 0 to maxX, fontLineSkip to maxY;
// paste it onto the screen at position 0, 0
// past an empty rectangle of SSDL_Display's background color at position 0, maxY-fontLineSkip

//I'm pretty sure this is all do-able


class SSDL_StreamIOSystem
{
public:
	static SSDL_StreamIOSystem& Instance ()
	{
		static SSDL_StreamIOSystem myStreamIOSystem;
		return myStreamIOSystem;
	}
	SSDL_StreamIOSystem(const SSDL_StreamIOSystem&) = delete;
	const SSDL_StreamIOSystem& operator= (const SSDL_StreamIOSystem&) = delete;

	TTF_Font* currentFont () const { return SSDL_GetCurrentFont (); }

	int  cursorX() const { return cursorX_; }
	int  cursorY() const { return cursorY_; }
	int& cursorX()		 { return cursorX_; }
	int& cursorY()		 { return cursorY_; }
	void setCursor (int x, int y) { cursorX_ = x; cursorY_ = y; }
	void eraseCharAtCursor (char c); //should not be called after changing font... odd things'll happen

private:
	SSDL_StreamIOSystem () : /*currentFont_ (NULL), */cursorX_(0), cursorY_(0)
	{
	}

	int cursorX_, cursorY_;
};

inline void SSDL_SetCursor (int x, int y) { SSDL_StreamIOSystem::Instance().setCursor (x, y); }

/*
If newFont goes away (wherever SSDL_SetStreamIOFont was called from, currentFont now points to nothing.
But we have no way of copying a font.  We could only store its file name and point and reload it, which
  is slow and not SDL-like.
So we'll tell the library users:  don't set to a font and then let that font go out of scope -- then
  the current font will be gone!  That's not too unreasonable.
*/

//Does all this really need to be template?

template<class _Elem, class _Traits = std::char_traits <_Elem> >
class SSDL_BufferOut: public std::basic_streambuf<_Elem, _Traits>
{
public:
    typedef _Elem                           char_type;
    typedef _Traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::off_type off_type;
    typedef typename traits_type::pos_type pos_type;

    SSDL_BufferOut()  { } 
	void printChar (_Elem ch); 
protected:
    int_type overflow (int_type c = traits_type::eof ());
};

template <class charType, class TraitsType>
void SSDL_BufferOut<charType, TraitsType>::printChar (charType ch)
{
	//fontLineSkip is how far to go down to next line
	//advance is how far to go right to next char
	//it varies except in fixed-width font
	//This may blow away my hope of saving time by sending entire strings -- or not.  Not sure
	// it'll be O(N) to find the advance, but I don't know how long it takes to render a string

	//Why all this casting to TTF_Font*?  Because SDL2_ttf library hasn't heard of const, so it objects
	// when I send a const pointer.
	int fontLineSkip = TTF_FontLineSkip ((TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont()); //and what font is that?
	int myAdvance;
	if (TTF_GlyphMetrics ((TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont(), ch, NULL, NULL, NULL, NULL, &myAdvance))
		throw SSDL_Exception ();
	static char buf[2] = {'\0'};
	//static int cursorX = 0, cursorY = 0; //DEFINITELY we will move this soon.

	switch (ch)
	{
	case '\n':
	case '\r':
		SSDL_StreamIOSystem::Instance().cursorY() += fontLineSkip;
		SSDL_StreamIOSystem::Instance().cursorX() =   0;
		break;
	case '\t':
		SSDL_StreamIOSystem::Instance().cursorX() = (((SSDL_StreamIOSystem::Instance().cursorX()/myAdvance)/8)+1)*8*myAdvance; //8 spaces per tab, by convention
		break;
	default:
		buf[0] = ch;
		SSDL_RenderText (buf, SSDL_StreamIOSystem::Instance().cursorX(), SSDL_StreamIOSystem::Instance().cursorY(), (TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont());
		SSDL_StreamIOSystem::Instance().cursorX() += myAdvance;
	}
}

template <class _ELem, class _Traits>
typename SSDL_BufferOut<_ELem, _Traits>::int_type
   SSDL_BufferOut<_ELem, _Traits>::overflow (typename SSDL_BufferOut<_ELem, _Traits>::int_type c)
{
	//This is likely inefficient:  better to send big chunks rather than individual chunks
	//Later, make SSDL use this aright.  For now...
	printChar (c);
    //PRINT IT ON THE SCREEN -- I think!
    //return std::basic_filebuf<_ELem, _Traits>::overflow (c);

    //return something that isn't _Traits::eof() -- unless we fail somehow
	//What if we're passed eof?  Should we return failure (eof)?

	return 0; //Is this OK?
	//return (! _Traits::eof ());
}

template <class charT, class traits = std::char_traits<charT> >
class SSDL_BufferIn: public std::basic_streambuf<charT, traits>
{
public:
	enum {BUFFER_SIZE = 256};

    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::off_type off_type;
    typedef typename traits_type::pos_type pos_type;

	SSDL_BufferIn ()
	{
		this->setg (buffer_, buffer_, buffer_);
		//This tells C++ where the read buffer starts, where it ends, and where the next char to read is
		// We offset it so there is an area to prepend things?  Don't know yet
	}
protected:
	int numCharsInBuffer () const { return int(this->egptr()-this->gptr()); }//it's the end position minus the next-char position
	char buffer_[BUFFER_SIZE]; //OK, but what if it grows too high? //should it be an int array?  setg says no

	int_type underflow ();
	int_type pbackfail (int_type c);
private:
	int_type  getMoreChars ();
	void egbump (int n)           //I wonder why this isn't built in?  moves end ptr by n units.
	{
		this->setg (this->eback(), this->gptr(), this->egptr()+n);
	}

	void handleBackspace(bool& charRemoved);			//used by getMoreChars ()
	void addACharacter(char c, bool& quit);				//used by getMoreChars ()
};

extern std::ostream sout;
extern std::istream ssin;

//As I understand it, underflow is here for when the istream class wants another character, it can get it
// from the source I provide (the buffer, if there is anything in it; if not, from the device that gives us chars)
template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::underflow ()
{
	if (numCharsInBuffer() > 0)						//If we have a char in the buffer to provide...
		return TraitsType::to_int_type (*(this->gptr()));	//... return it!  Job complete
	else if (getMoreChars ()>0)						//Can we get one from the device?
		return TraitsType::to_int_type (*(this->gptr()));	//If so, we did it; return the next char available
	else											//NO way to get a character!  Oh, no!  Return failure
		return TraitsType::eof ();
}

template <class charType, class TraitsType>
void SSDL_BufferIn<charType, TraitsType>::handleBackspace(bool& charRemoved)	//process a backspace in my input
{
	charRemoved = false;

	if (this->egptr() != this->eback() && SSDL_StreamIOSystem::Instance().cursorX() > 0) //last condition:  can we be assured it's right?  Cd we be
		//off by a few pixels?
	{
		char prevChar = *((this->egptr()) - 1);
		switch (prevChar)
		{
		case '\n':
		case '\r':
		case -1: //eof
			break;
		default:
			SSDL_StreamIOSystem::Instance().cursorX()
				-= SSDL_Display::Instance().advance(prevChar);

			SSDL_StreamIOSystem::Instance().eraseCharAtCursor(prevChar); //erase the char backspaced over

			assert(SSDL_StreamIOSystem::Instance().cursorX() >= 0); //we shd've had at least 1 char on line, plus my new blank space!
			egbump(-1); //move gptr back 1 space, so we're ignoring where we were
			charRemoved = true;

			break;
		}
	}
}

inline bool isNumLockOn (SDL_Keymod mod) { return (mod & KMOD_NUM) != 0; }

//We got a character through ssin... display it and send it where it should go.
template <class charType, class TraitsType>
void  SSDL_BufferIn<charType, TraitsType>::addACharacter(char c, bool& OKWereDone)
{
	if (this->gptr() >= this->eback() + BUFFER_SIZE - 1) //no room!
	{
		OKWereDone = true;	//What will this look like?  Test with tiny buffer size.
		return;
	}

	sout << c;
	*(this->egptr()) = c;
	egbump(1); //move end pointer one step further
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type  SSDL_BufferIn<charType, TraitsType>::getMoreChars ()
{
	//As it is, unless you backspace, you _never_ have gptr going back...and it should!  Can I be guaranteed
	// that every time istream calls underflow, it ate all the chars SSDL_BufferIn provided?  Yes!  So I will
	//move everything back.

	assert (this->eback () == buffer_); //if not, why not?
	if (this->gptr() != this->eback())
		memmove (this->eback(), this->gptr(), this->egptr()-this->gptr()); // I think this'll move things back!

	bool OKWereDone = false;
	int  numCharsRead = 0;

	while (! OKWereDone) //Looks a lot like SSDL_WaitEvent...
	{
		SDL_Event event;
		SSDL_RenderPresent();	//Why this?  because it's annoying to have the screen not update while you're
								//waiting for an event!

		while (SDL_PollEvent(&event) != 0)
		{
			SDL_Keymod   mod		= SDL_GetModState();
			bool	     isNumLock	= isNumLockOn(mod);
			SDL_Scancode scancode;

				//If a quit message came, let's get out.
			SSDL_CheckForQuitMessages(event);
			if (SSDL_Display::Instance().isTimeToQuit())
			{
				OKWereDone = true;  break;
			}

				//Now let's process two kinds of messages.  SDL_KEYDOWN for when we get a backspace or a return
				//SDL_TEXTINPUT for when we get useful, printable text.

			switch (event.type)
			{
			case SDL_KEYDOWN:
				scancode = event.key.keysym.scancode;
				if (scancode == SDL_SCANCODE_BACKSPACE || (!isNumLock && scancode == SDL_SCANCODE_KP_BACKSPACE))
				{
					bool charRemoved;
					handleBackspace(charRemoved);
					if (charRemoved) --numCharsRead;
				}
				if (scancode == SDL_SCANCODE_RETURN || scancode == SDL_SCANCODE_RETURN2)
				{
					OKWereDone = true;

					addACharacter(event.key.keysym.sym, OKWereDone);		++numCharsRead;
				}
				break;
			case SDL_TEXTINPUT:
				addACharacter(event.text.text[0], OKWereDone);				++numCharsRead;
			}
		}
	}

	return numCharsRead;

	////assert:  numCharsInBuffer() == 0, that is, gptr() == eback() == egptr(), that is, start==next==finish
	//int result = getCharsSomehow ();
	//if (result <= 0) return -1; //getChars failed; return failure.  Should NEVER HAPPEN
	//else
	//	setg (buffer_ ,
	//		  buffer_ ,
	//		  buffer_ +result;
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::pbackfail (int_type c)
{
	if (this->gptr() == this->eback ()) //if there is no further back we can go -- we're at start of buffer
		return TraitsType::eof (); //then failse
	else
	{
		this->gbump(-1); //back up one space
					//and if there's no EOF where we just went, put our char there
		if (! TraitsType::eq_int_type (c, TraitsType::eof ()))
		{
			*(this->gptr()) = TraitsType::to_char_type (c);
			return c;
		}
		else
			return TraitsType::not_eof(c);
	}
}


static bool isEscapeMeansQuit = true;

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{
    return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
    if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
    if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
        && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
        SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
    SSDL_RenderPresent();

    while (!SSDL_Display::Instance().isTimeToQuit())
    {
        if (SDL_WaitEvent(&sdlEvent) == 0) throw SSDL_Exception();
        SSDL_CheckForQuitMessages(sdlEvent);
        if (sdlEvent.type == eventType) return;
    }
}

void SSDL_DefaultEventHandler()
{
    SSDL_Event event;

    while (SSDL_PollEvent(event))
        switch (event.type)
        {
        case SDL_QUIT:    SSDL_DeclareQuit(); break;
        case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();
        case SDL_WINDOWEVENT_MAXIMIZED:
        case SDL_WINDOWEVENT_RESTORED:    
        case SDL_WINDOWEVENT_SIZE_CHANGED:
        case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
            break;
        }
}

int  SSDL_WaitMouse()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
    return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_KEYDOWN, event);
    return event.key.keysym.sym;
}

  //This is the SSDL_Display -- the screen you see when the program runs. 

#include "SSDL_font.h"

#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#define FEDORA_FONT_PATH "/usr/share/fonts/msttcore/"
#define OPENSUSE_FONT_PATH "/usr/share/fonts/truetype/"
#define OPENSUSE_FONT_PATH_NEW "/usr/share/fonts/msttcorefonts/"
#define MANJARO_FONT_PATH "/usr/share/fonts/TTF"

SSDL_Display::SSDL_Display() : isTimeToQuit_(false)
{
    std::set_terminate(SSDL_terminate);

    if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
        throw SSDL_Exception();


    sdlWindow_ = SDL_CreateWindow("",              //no title by default
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        DEFAULT_WIDTH, DEFAULT_HEIGHT,
        0);           //flags are 0 by default
    if (!sdlWindow_) throw SSDL_Exception();

    //defaults below:  index shd be -1 (pick the first renderer that works best)
    //rendererFlags should be 0
    int rendererIndex = -1;
    int rendererFlags = 0;
    sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

    if (!sdlRenderer_) throw SSDL_Exception();

    SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

    SDL_ClearError();
    
    static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
    if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw SSDL_Exception();

    if (TTF_Init() == -1) throw SSDL_Exception();

    SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);

    int point = 14;
    std::string filename = "arial.ttf"; 
    std::string finalFilename;

    systemFontPath_ = UBUNTU_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    if (!currentFont_) //OK, if it's not on the UBUNTU path, is it in the FEDORA path?
    {
        finalFilename = SSDL_SystemFontPath(FEDORA_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = FEDORA_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the OPENSUSE path?
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the new OPENSUSE path? I find different paths for different installs of msttcore-fonts
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH_NEW, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH_NEW;
    }
    if (!currentFont_)  //If not, is it in the MANJARO path?
    {
        finalFilename = SSDL_SystemFontPath(MANJARO_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = MANJARO_FONT_PATH;
    }

    if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Missing ") + filename +
            ". Either msttcore fonts aren't installed or the path to them is unknown.\n"
            "If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";

        setCrashMessage(errorMsg); 
        throw SSDL_Exception(errorMsg.c_str());
    }

    TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
}

TTF_Font* SSDL_GetCurrentFont()
{
    return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
    SSDL_Display::Instance().setCurrentFont(newFont);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
    strcpy(temp, str);

    char* nextLine = strtok(temp, "\n\r");
    while (nextLine)
    {
        RenderTextLine(nextLine, x, y, font, isCentered);
        y += fontLineSkip();
        nextLine = strtok(NULL, "\n\r");
    }
    delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    SDL_Surface* surfaceToPrintOn;
    surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
    //arg -- having to cast away that const again.  Why should I have to?
    //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
    //I can fix this with my own calls
    if (!surfaceToPrintOn) throw SSDL_Exception();


    SDL_Texture* textureToPrint;
    textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

    if (!textureToPrint) throw SSDL_Exception();

    int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
    SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

    if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
        throw SSDL_Exception();
    //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
    //Another time perhaps
    SDL_DestroyTexture(textureToPrint);
    SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
    return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}


void SSDL_RenderClear(const SSDL_Color& c)
{
    SSDL_Color old = SSDL_GetRenderDrawColor();
    SSDL_SetRenderDrawColor(c);
    SSDL_RenderClearAux();
    SSDL_SetRenderDrawColor(old);
}

void SSDL_Display::setWindowSize(int w, int h)
{
#ifdef __unix__
    SDL_Event e; while (SDL_PollEvent(&e));
#endif
    //In Unix sometimes if I don't to this, the
    //next call to SDL_GetWindowSize will get the old
    //dimensions, not the new. Go figure.

    SDL_SetWindowSize(SSDL_Display::Instance(), w, h);

#ifdef __unix__
    SDL_RenderPresent(SSDL_Display::Instance());
    for (int i = 0; i < 40; ++i) //Must be 6 or more to be reliable
        SDL_Delay(30);          //10 works; 1 doesn't
      //A single SDL_Delay(60); usually works
      //but sometimes does not
      //The current numbers 40x30, are there to make it work with OpenSuSe. Would like to have
      // a more rational long-term fix. Maybe SDL.org will have one by now.
#endif
}

  //This is SSDL_Font, a wrapper for TTF_Font

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
    std::string newPath(fontPath); newPath += filename;
    if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
    return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
    string finalFilename;
    TTF_Font* currentFont_; //WSB: change to "result"

//      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "systemFontPath_", SSDL_Display::Instance().systemFontPath(), NULL);
    finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "final filename", finalFilename.c_str(), NULL);

    if (!currentFont_) 
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); 
        throw SSDL_Exception();
    }
    return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
    char* strEnd = (char*)str + strlen(str) - 1;
    char* substrEnd = (char*)substr + strlen(substr) - 1;

    for (;; --strEnd, --substrEnd)
    {
        if (toupper(*substrEnd) != toupper(*strEnd))  return false;

        if (substrEnd <= substr)    return true;
        else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
    SSDL_Display::Instance(); 

    string finalFilename = filename;
    if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

    TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
    if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); 
        throw SSDL_Exception();
    }
    return result;
}

//#include "SSDL_singletonManager.h"

void atexitHandler();

class SSDL_SingletonManager
{
public:
    SSDL_SingletonManager()
    {
        atexit(atexitHandler);
        SSDL_Display::Instance();
    }
    std::string crashMessage;
};

static SSDL_SingletonManager singletonManagerInstance;

void setCrashMessage(const std::string& msg) { singletonManagerInstance.crashMessage = msg; }

void atexitHandler()
{
    if (singletonManagerInstance.crashMessage.length()) //if there was a crash message...display it
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", singletonManagerInstance.crashMessage.c_str(), NULL);

}

#include "SSDL_timer.h"

static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
    SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
    //	SDL_Rect rect = {0, 0, 1, 1};

        //erase that last char by replacing with background color
    SDL_Rect newRect;
    newRect.x = cursorX(); newRect.y = cursorY();
    newRect.w = SSDL_Display::Instance().advance(c);
    newRect.h = SSDL_Display::Instance().fontLineSkip();
    Uint8 r, g, b, a;
    SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
    SSDL_Color background_ = SSDL_Display::Instance().background();
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
    SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
    SSDL_RenderPresent();

    SDL_FreeSurface(result);
}


class SSDL_Timer
{
public:
    static SSDL_Timer& Instance()
    {
        static SSDL_Timer myInstance;
        return myInstance;
    }

    SSDL_Timer(const SSDL_Timer&) = delete;
    const SSDL_Timer& operator= (const SSDL_Timer&) = delete;

    void setFramesPerSecond(Uint32 fps) { frameDuration_ = 1000 / fps; }
    //maybe I shd just do frame duration as 1/60 of a second?
    bool sync();
private:
    SSDL_Timer() : timeAtNextFrame_(0)
    {
        setFramesPerSecond(60);	//default to 60 frames per second.
    }

    Uint32 frameDuration_;		//in milliseconds
    Uint32 timeAtNextFrame_;	//in milliseconds, counting from time we started SDL
};

// Frame Per Second Function  , put this in a loop
bool SSDL_Timer::sync()
{
    if (SSDL_Display::Instance().isTimeToQuit()) return false;

    SSDL_RenderPresent();

    Uint32 currentTime = SDL_GetTicks();
    if (timeAtNextFrame_ > currentTime)
        SDL_Delay(timeAtNextFrame_ - currentTime);

    timeAtNextFrame_ = currentTime + frameDuration_;

    return true;
}

bool SSDL_IsQuitMessage()
{
    SSDL_DefaultEventHandler(); return !SSDL_IsNextFrame();
}

void SSDL_SetFramesPerSecond(Uint32 FPS) { SSDL_Timer::Instance().setFramesPerSecond(FPS); }
bool SSDL_IsNextFrame() { return SSDL_Timer::Instance().sync(); }

int main (int argc, char** argv)
{
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();

  std::string str;  ssin >> str;

  return 0;
}
