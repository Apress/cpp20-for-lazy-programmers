#include <cmath> //for sqrt
#include <sstream>
#include <cstring> //for strcmp
#include <SDL.h>
#include "SSDL_display.h"
#include "SSDL_image.h"
#include "SSDL_font.h"
#include "SSDL_sound.h"
#include "SSDL_timer.h"
#include "SSDL_io.h"
#include "SSDL_stream.h"
#include "SSDL_sprite.h"
#include "SSDL_draw.h"
#include "SSDL_color.h"

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);


#include "SSDL_exception.h"

void SSDL_terminate() //DOES NOT GET CALLED when we are in the Debugger
{
    try
    {
        throw;
    }
    catch (const SSDL_Exception& c)
    {
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", c, NULL); 
    }

    abort();
}



#include "SSDL.h" //for refreshDisplay

static bool isEscapeMeansQuit = true;

void SSDL_ToggleEscapeMeansQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{
    return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
    if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
    if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
        && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
        SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
    //if (isVisible) 
    SSDL_RenderPresent();
    //Why this?  because it's annoying to have the screen not update while you're
    //waiting for an event!

    while (!SSDL_Display::Instance().isTimeToQuit())
    {
        if (SDL_WaitEvent(&sdlEvent) == 0) throw SSDL_Exception();
        SSDL_CheckForQuitMessages(sdlEvent);
        if (sdlEvent.type == eventType) return;
    }
}

void SSDL_ToggleEscapeIsQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

void SSDL_DefaultEventHandler()
{
    SSDL_Event event;

    while (SSDL_PollEvent(event))
        switch (event.type)
        {
        case SDL_QUIT:    SSDL_DeclareQuit(); break;
        case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();
        case SDL_WINDOWEVENT_MAXIMIZED:
        case SDL_WINDOWEVENT_RESTORED:     //isVisible = true; 

            //...and if it was just made visible, or was obscured and is now less so, or
            //  was resized, do an immediate update
        case SDL_WINDOWEVENT_SIZE_CHANGED:
        case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
            break;
        }
}

int  SSDL_WaitMouse()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
    return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
    SDL_Event event;
    SSDL_WaitEvent(SDL_KEYDOWN, event);
    return event.key.keysym.sym;
}


#include <SDL.h>
#include "SSDL_display.h"
#include "SSDL_image.h"

SSDL_Image SSDL_LoadImage(const char* filename)
{
    SSDL_Display::Instance(); //be sure SDL is initialized before calling IMG_Load

    SDL_Surface* sdlSurface = IMG_Load(filename);
    if (!sdlSurface) throw SSDL_Exception();

    SDL_Texture* result = SDL_CreateTextureFromSurface(SSDL_Display::Instance(), sdlSurface);
    if (!result) throw SSDL_Exception(); //sure would be nice if we could convey what
    //file failed!
    SDL_FreeSurface(sdlSurface);

    return SSDL_Image(result);
}

  //This is the SSDL_Display -- the screen you see when the program runs. 

#include <exception>
#include <cstring> 
#include <SDL.h>
#include <SDL_ttf.h>
#include <SDL_image.h>
#include "SSDL_display.h"
#include "SSDL_image.h"
#include "SSDL_font.h"

#define WINDOWS_FONT_PATH "C:\\Windows\\Fonts\\"
#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#define FEDORA_FONT_PATH "/usr/share/fonts/msttcore/"
#define OPENSUSE_FONT_PATH "/usr/share/fonts/truetype/"
#define OPENSUSE_FONT_PATH_NEW "/usr/share/fonts/msttcorefonts/"
#define MANJARO_FONT_PATH "/usr/share/fonts/TTF"

SSDL_Display::SSDL_Display() : isTimeToQuit_(false)
{
    std::set_terminate(SSDL_terminate);

    if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
        throw SSDL_Exception();


    sdlWindow_ = SDL_CreateWindow("",              //no title by default
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        DEFAULT_WIDTH, DEFAULT_HEIGHT,
        0);           //flags are 0 by default
    if (!sdlWindow_) throw SSDL_Exception();

    //defaults below:  index shd be -1 (pick the first renderer that works best)
    //rendererFlags should be 0
    int rendererIndex = -1;
    int rendererFlags = 0;
    sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

    if (!sdlRenderer_) throw SSDL_Exception();

    //sdlSurface_ = SDL_GetWindowSurface(sdlWindow_); //WSB: It would be polite to free this later

    //if (! sdlSurface_ ) throw SSDL_Exception ();

    //Some distros Unix, sometimes, don't start with a blank screen. Make them. 2021-06-08
    SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

    SDL_ClearError(); //Why? SDL2_Image documentation warns that IMG_Init does not necessarily
    // set the Error, so I figure I'd better clear it.  I hope it sets it if there's an error!
    static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
    if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw SSDL_Exception();

    if (TTF_Init() == -1) throw SSDL_Exception();

    //Had to avoid calling SSDL_SetRenderDrawColor because it calls SSDL_Display::Instance
    //which calls this ctor, and a thread-safe mechanism got this thing stuck waiting forever
    SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);//the default color for drawing is WHITE.  I don't use the constant
    //because I don't _know_ that it's been initialized yet.

    int point = 14;
    std::string filename = "arial.ttf"; //This default is recorded in C++20 for Lazy Programmers, so DON'T CHANGE
    std::string finalFilename;

#ifdef _WIN32
    systemFontPath_ = WINDOWS_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
#else //Unix
    systemFontPath_ = UBUNTU_FONT_PATH;
    finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    if (!currentFont_) //OK, if it's not on the UBUNTU path, is it in the FEDORA path?
    {
        finalFilename = SSDL_SystemFontPath(FEDORA_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = FEDORA_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the OPENSUSE path?
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH;
    }
    if (!currentFont_)  //If not, is it in the new OPENSUSE path? I find different paths for different installs of msttcore-fonts
    {
        finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH_NEW, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = OPENSUSE_FONT_PATH_NEW;
    }
    if (!currentFont_)  //If not, is it in the MANJARO path?
    {
        finalFilename = SSDL_SystemFontPath(MANJARO_FONT_PATH, filename.c_str());
        currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
        systemFontPath_ = MANJARO_FONT_PATH;
    }
#endif

    if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Missing ") + filename +
            ". Either msttcore fonts aren't installed or the path to them is unknown.\n"
            "If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";
        //Look up a few lines for how to add your own fonts path.

        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
        //VS in debugger crashes (good) and shows you where (good) but doesn't
        // call the function specified in set_terminate (bad)
        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception(errorMsg.c_str());
    }

    TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
}

TTF_Font* SSDL_GetCurrentFont()
{
    return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
    SSDL_Display::Instance().setCurrentFont(newFont);
}


void SSDL_RenderImage(SDL_Texture* image, int x, int y, int stretchWidth, int stretchHeight)
{
    SDL_Rect dst; //src is dimensions of image; dst is where it's goin on screen
    dst.x = x; dst.y = y;

    if (stretchWidth == 0 || stretchHeight == 0) //what if they put in 0 for either?  then dont' stretch
        SDL_QueryTexture(image, NULL, NULL, &dst.w, &dst.h); //get width and height of image
    else
    {
        dst.w = stretchWidth; dst.h = stretchHeight;
    }

    SDL_RenderCopy(SSDL_Display::Instance(), image, NULL, &dst);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
    strcpy(temp, str);

    char* nextLine = strtok(temp, "\n\r");
    while (nextLine)
    {
        RenderTextLine(nextLine, x, y, font, isCentered);
        y += fontLineSkip();
        nextLine = strtok(NULL, "\n\r");
    }
    delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
    SDL_Surface* surfaceToPrintOn;
    surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
    //arg -- having to cast away that const again.  Why should I have to?
    //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
    //I can fix this with my own calls
    if (!surfaceToPrintOn) throw SSDL_Exception();


    SDL_Texture* textureToPrint;
    textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

    if (!textureToPrint) throw SSDL_Exception();

    int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
    SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

    if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
        throw SSDL_Exception();
    //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
    //Another time perhaps
    SDL_DestroyTexture(textureToPrint);
    SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
    return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}


void SSDL_RenderClear(const SSDL_Color& c)
{
    SSDL_Color old = SSDL_GetRenderDrawColor();
    SSDL_SetRenderDrawColor(c);
    SSDL_RenderClearAux();
    SSDL_SetRenderDrawColor(old);
}

void SSDL_Display::setWindowSize(int w, int h)
{
#ifdef __unix__
    SDL_Event e; while (SDL_PollEvent(&e));
#endif
    //In Unix sometimes if I don't to this, the
    //next call to SDL_GetWindowSize will get the old
    //dimensions, not the new. Go figure.

    SDL_SetWindowSize(SSDL_Display::Instance(), w, h);

#ifdef __unix__
    SDL_RenderPresent(SSDL_Display::Instance());
    for (int i = 0; i < 40; ++i) //Must be 6 or more to be reliable
        SDL_Delay(30);          //10 works; 1 doesn't
      //A single SDL_Delay(60); usually works
      //but sometimes does not
      //The current numbers 40x30, are there to make it work with OpenSuSe. Would like to have
      // a more rational long-term fix. Maybe SDL.org will have one by now.
#endif
}

  //This is SSDL_Font, a wrapper for TTF_Font

#include <string>
#include <cstring>
#include <sstream>
#include "SSDL_font.h"
#include "SSDL_exception.h"
#include "SSDL_display.h"

using namespace std;

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
    std::string newPath(fontPath); newPath += filename;
    if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
    return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
    string finalFilename;
    TTF_Font* currentFont_; //WSB: change to "result"

//      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "systemFontPath_", SSDL_Display::Instance().systemFontPath(), NULL);
    finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
    currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
    //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "final filename", finalFilename.c_str(), NULL);

    if (!currentFont_) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
                                                        //VS in debugger crashes (good) and shows you where (good) but doesn't
                                                        // call the function specified in set_terminate (bad)
                                                        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception();
    }
    return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
    char* strEnd = (char*)str + strlen(str) - 1;
    char* substrEnd = (char*)substr + strlen(substr) - 1;

    for (;; --strEnd, --substrEnd)
    {
        if (toupper(*substrEnd) != toupper(*strEnd))  return false;

        if (substrEnd <= substr)    return true;
        else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
    SSDL_Display::Instance(); //be sure SSDL is initialized...

    //We hope the filename ends in .ttf.  If not, and there's no extension, append it.
    //If not, and there is an (incorrect) extension, go ahead and append it, and watch it fail.

    string finalFilename = filename;
    if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

    TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
    if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
        std::string errorMsg = std::string("Can't open font ") + filename + ".";
        setCrashMessage(errorMsg); //Redundant? Maybe. But the 3 compilers seem inconsistent in their handling of exceptions
                                                        //VS in debugger crashes (good) and shows you where (good) but doesn't
                                                        // call the function specified in set_terminate (bad)
                                                        //VS MinGW and Unix, w/o debugging, show the crash message and abort -- good.
        throw SSDL_Exception();
    }
    return result;
}


#include <string>
#include <SDL_image.h>
#include "SSDL_display.h"
#include "SSDL_sound.h"
#include "SSDL_singletonManager.h"

void atexitHandler();

class SSDL_SingletonManager
{
public:
    SSDL_SingletonManager()
    {
        atexit(atexitHandler);
        SSDL_Display::Instance();
        SSDL_SoundSystem::Instance();
    }
    std::string crashMessage;
};

static SSDL_SingletonManager singletonManagerInstance;

void setCrashMessage(const std::string& msg) { singletonManagerInstance.crashMessage = msg; }

void atexitHandler()
{
    if (singletonManagerInstance.crashMessage.length()) //if there was a crash message...display it
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", singletonManagerInstance.crashMessage.c_str(), NULL);

}


//This is the Sound System.  It provides. all access to sounds.

#include "SSDL_exception.h"
#include "SSDL_sound.h"

//SSDL SoundSystem
SSDL_SoundSystem::SSDL_SoundSystem(int freq, Uint16 format, int channels, int chunkSize)
{
    //Start SDL2_Mixer. Apparently you don't really need to...
    //int soundsSupported = Mix_Init(MIX_INIT_FLAC | MIX_INIT_MOD | MIX_INIT_MP3 | MIX_INIT_OGG);
    //if (!soundsSupported) throw SSDL_Exception();

    initializedOK_ = (Mix_OpenAudio(freq, format, channels, chunkSize) != -1); //8-7-2017
    if (!initializedOK_) SDL_ClearError(); //or we'll get this complaint later, when it makes no sense
    //I commented out all refs to throwing SSDL_Exception in SSDL_sound.*, so we could get by with this
    //It may not be the best solution.
    //Fix later.  8-7-2017

    //if (Mix_OpenAudio(freq, format, channels, chunkSize) == -1)
    //		throw SSDL_Exception (); 
}

Mix_Music* SSDL_Music::music_ = NULL;

void SSDL_PlaySound(const SSDL_Sound& sound, int repeats)
{
    int result = Mix_PlayChannel(sound, sound, repeats);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_FadeInSound(SSDL_Sound& sound, int repeats, int ms)
{
    int result = Mix_FadeInChannel(sound, sound, repeats, ms);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_PlaySoundTimed(SSDL_Sound& sound, int repeats, int ticks)
{
    int result = Mix_PlayChannelTimed(sound, sound, repeats, ticks);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

void SSDL_FadeInSoundTimed(SSDL_Sound& sound, int repeats, int ms, int ticks)
{
    int result = Mix_FadeInChannelTimed(sound, sound, repeats, ms, ticks);
    if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
    sound.setChannel(result);
}

#include "SSDL_timer.h"

static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
    SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
    //	SDL_Rect rect = {0, 0, 1, 1};

        //erase that last char by replacing with background color
    SDL_Rect newRect;
    newRect.x = cursorX(); newRect.y = cursorY();
    newRect.w = SSDL_Display::Instance().advance(c);
    newRect.h = SSDL_Display::Instance().fontLineSkip();
    Uint8 r, g, b, a;
    SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
    SSDL_Color background_ = SSDL_Display::Instance().background();
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
    SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
    SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
    SSDL_RenderPresent();

    SDL_FreeSurface(result);
}


class SSDL_Timer
{
public:
    static SSDL_Timer& Instance()
    {
        static SSDL_Timer myInstance;
        return myInstance;
    }

    SSDL_Timer(const SSDL_Timer&) = delete;
    const SSDL_Timer& operator= (const SSDL_Timer&) = delete;

    void setFramesPerSecond(Uint32 fps) { frameDuration_ = 1000 / fps; }
    //maybe I shd just do frame duration as 1/60 of a second?
    bool sync();
private:
    SSDL_Timer() : timeAtNextFrame_(0)
    {
        setFramesPerSecond(60);	//default to 60 frames per second.
    }

    Uint32 frameDuration_;		//in milliseconds
    Uint32 timeAtNextFrame_;	//in milliseconds, counting from time we started SDL
};

// Frame Per Second Function  , put this in a loop
bool SSDL_Timer::sync()
{
    if (SSDL_Display::Instance().isTimeToQuit()) return false;

    SSDL_RenderPresent();

    //SDL_GetTicks returns current time (since SDL was initialized)
    //if the time at the next frame is later than that, wait.  How long?  The difference
    Uint32 currentTime = SDL_GetTicks();
    if (timeAtNextFrame_ > currentTime)
        SDL_Delay(timeAtNextFrame_ - currentTime);

    //Now set the time at the next frame to the current time, plus the duration of one frame
    timeAtNextFrame_ = currentTime + frameDuration_;

    return true;
}

bool SSDL_IsQuitMessage()
{
    SSDL_DefaultEventHandler();
    return !SSDL_IsNextFrame();
}

void SSDL_SetFramesPerSecond(Uint32 FPS) { SSDL_Timer::Instance().setFramesPerSecond(FPS); }
bool SSDL_IsNextFrame() { return SSDL_Timer::Instance().sync(); }

int main (int argc, char** argv)
{
  SSDL_SetWindowSize  (640, 480);
  sout << "Click mouse.\n";
  SSDL_WaitMouse();

  //Test drawing, SSDL_ToggleEscapeIsQuit, RenderClear using erase color
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();

  std::string str;

  sout << "Default font, GREEN background.\n";
  ssin >> str;

  return 0;
}
