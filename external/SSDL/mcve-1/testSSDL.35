#include <cmath> 
#include <cassert>
#include <sstream>
#include <cstring> 
#include <string>
#include <SDL.h>
#include <exception>
#include <cstring> 
#include <SDL_ttf.h>
#include <memory>

using namespace std;

struct SSDL_Color : public SDL_Color
{
public:
  constexpr SSDL_Color (SDL_Color& other) : SDL_Color(other) {}
  constexpr SSDL_Color (int rIn = 0, int gIn = 0, int bIn = 0, int alpha = 255) : SDL_Color()
  {
    r = rIn; g = gIn; b = bIn; a = alpha;
  }
  constexpr SSDL_Color            (const SSDL_Color& other) = default;
  constexpr SSDL_Color& operator= (const SSDL_Color& other) = default;
	
  constexpr bool operator== (const SSDL_Color& other) const
  {
    return r == other.r && g == other.g&& b == other.b && a == other.a;
  }
};

inline constexpr SSDL_Color SSDL_CreateColor (int r, int g, int b, int a=255) { return SSDL_Color (r, g, b, a); }

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), GREEN (0, 255, 0);

class SSDL_Font
{
public:
  SSDL_Font(TTF_Font* font = NULL) : ttfFont_(NULL)
  {
    ttfFont_.reset(font, TTF_CloseFont);
  }
  SSDL_Font(const SSDL_Font& f) { *this = f; }

  const SSDL_Font& operator= (const SSDL_Font& f) { ttfFont_ = f.ttfFont_; return *this; }
  operator       TTF_Font* ()       { return ttfFont_.get(); }
  operator       TTF_Font* () const { return ttfFont_.get(); }

private:
  std::shared_ptr<TTF_Font> ttfFont_;
};

TTF_Font* SSDL_OpenFont           (const char* filename, int point);

std::string SSDL_SystemFontPath(const char* fontPath, const char* filename);

TTF_Font* SSDL_OpenSystemFont  (const char* filename, int point);

//What font is current?
TTF_Font* SSDL_GetCurrentFont();
void      SSDL_SetFont(TTF_Font* newFont);

//Useful for adding (or not) ".ttf" to the end of filenames
bool matchFromEnd(const char* str, const char* substr);


class SSDL_Image;

class SSDL_Display
{
public:
  enum {DEFAULT_WIDTH = 640, DEFAULT_HEIGHT = 480};

  SSDL_Display                  (const SSDL_Display&) = delete;
  const SSDL_Display& operator= (const SSDL_Display&) = delete;

  static SSDL_Display& Instance ()
  {
    static SSDL_Display myInstance;
    return myInstance;
  }       

  void RenderTextLine    (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
  void RenderText        (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
  //void scrollVertically  (unsigned int pixels); //Not currently done; maybe nice in next version

  bool isTimeToQuit () const { return isTimeToQuit_; }
  void declareTimeToQuit ()  { isTimeToQuit_ = true; }

  operator SDL_Renderer* () const { return sdlRenderer_; }
  operator SDL_Window*   () const { return sdlWindow_;   }

  void setWindowSize (int w, int h);

  int  advance(char ch) const
  {
    int result;
    if (TTF_GlyphMetrics ((TTF_Font*) (const TTF_Font*) SSDL_GetCurrentFont(), ch, NULL, NULL, NULL, NULL, &result))
      throw "Oh, no!";
    return result;
  }
  int fontLineSkip () const
  {
    return TTF_FontLineSkip((TTF_Font*) SSDL_GetCurrentFont());
  }


  const SSDL_Color& background () const { return background_; }
  void     setBackground (const SSDL_Color& c) { background_ = c; }

  TTF_Font* currentFont() const { return currentFont_; }
  void setCurrentFont(TTF_Font* newFont) { currentFont_ = newFont; }
  const char* systemFontPath () const { return systemFontPath_.c_str();}
private:
  SDL_Window*   sdlWindow_;
  SDL_Renderer* sdlRenderer_;
  TTF_Font*         currentFont_;
  std::string   systemFontPath_;
  SSDL_Color        background_;

  bool              isTimeToQuit_;

  SSDL_Display  ();       
  ~SSDL_Display ();
};



inline bool SSDL_IsQuit      () { return SSDL_Display::Instance().isTimeToQuit(); }
inline void SSDL_DeclareQuit () { SSDL_Display::Instance().declareTimeToQuit();   }

inline void SSDL_SetRenderDrawColor (const SSDL_Color& c)
{
  SDL_SetRenderDrawColor(SSDL_Display::Instance(), c.r, c.g, c.b, c.a);   
}

inline SSDL_Color SSDL_GetRenderDrawColor ()
{
  SSDL_Color c;
  SDL_GetRenderDrawColor (SSDL_Display::Instance(), &c.r, &c.g, &c.b, &c.a);
  return c;
}

inline void SSDL_SetRenderEraseColor (const SSDL_Color& c)
{
  SSDL_Display::Instance().setBackground (c);
}

inline void SSDL_RenderClearAux ()
{
  if (SDL_RenderClear (SSDL_Display::Instance()) < 0) throw "Oh, no!";
}

void SSDL_RenderClear(const SSDL_Color& c = SSDL_Display::Instance().background());

inline
void SSDL_RenderTextAux (const char* str, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
  SSDL_Display::Instance().RenderText (str, x, y, font);
}

template <typename T>
inline
void SSDL_RenderText (const T& thing, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
  std::ostringstream os; os << thing;
  SSDL_RenderTextAux (os.str().c_str(), x, y, font);
}

inline void SSDL_RenderImage (SDL_Texture* image, const SDL_Rect& src, const SDL_Rect& dst)
{
  if (SDL_RenderCopy (SSDL_Display::Instance(), image, &src, &dst) != 0) throw "Oh, no!";
}

inline void SSDL_RenderPresent () { SDL_RenderPresent (SSDL_Display::Instance ()); }

//SSDL_stream.h stuff

//Various functions related to I/O (mouse or keyboard)

typedef SDL_Event SSDL_Event; //simple renaming -- now you can use either

bool SSDL_IsKeyPressed (SDL_Keycode whichKey);
void SSDL_WaitEvent (Uint32 eventType, SDL_Event& event);

//int         SSDL_WaitMouse();
SDL_Keycode SSDL_WaitKey  (); //SDL_Keycode is SDL's virtual key rep. *Sometimes* casting to char gets you what you hit

void SSDL_ToggleEscapeIsQuit ();

inline int SSDL_PollEvent (SDL_Event& event) { return SDL_PollEvent (&event); }

void SSDL_DefaultEventHandler ();

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent);


//#include "SSDL_image.h"

#include <SDL_image.h>

inline
void SSDL_DestroyTexture(SDL_Texture*& p) 
{
  if (p) 
    { 
      SDL_DestroyTexture(p); 
      p = nullptr; 
    }
}

class SSDL_Image
{
public:
  SSDL_Image() : sdlTexture_(NULL)  {  }
  SSDL_Image (SDL_Texture* sdlTexture) : sdlTexture_ (NULL) 
  { 
    sdlTexture_.reset(sdlTexture, SSDL_DestroyTexture);
  }
  SSDL_Image(const SSDL_Image& other) { *this = other;  }

  operator       SDL_Texture* ()		 { return sdlTexture_.get (); }
  operator       SDL_Texture* () const { return sdlTexture_.get (); }
	
  const SSDL_Image& operator= (const SSDL_Image& other)
  {
    sdlTexture_ = other.sdlTexture_; return *this;
  }
private:
  std::shared_ptr<SDL_Texture> sdlTexture_;
};

SSDL_Image SSDL_LoadImage(const char* filename);





class SSDL_StreamIOSystem
{
public:
  static SSDL_StreamIOSystem& Instance ()
  {
    static SSDL_StreamIOSystem myStreamIOSystem;
    return myStreamIOSystem;
  }
  SSDL_StreamIOSystem(const SSDL_StreamIOSystem&) = delete;
  const SSDL_StreamIOSystem& operator= (const SSDL_StreamIOSystem&) = delete;

  TTF_Font* currentFont () const { return SSDL_GetCurrentFont (); }

  int  cursorX() const { return cursorX_; }
  int  cursorY() const { return cursorY_; }
  int& cursorX()		 { return cursorX_; }
  int& cursorY()		 { return cursorY_; }
  void setCursor (int x, int y) { cursorX_ = x; cursorY_ = y; }
  void eraseCharAtCursor (char c); //should not be called after changing font... odd things'll happen

private:
  SSDL_StreamIOSystem () : /*currentFont_ (NULL), */cursorX_(0), cursorY_(0)
  {
  }

  int cursorX_, cursorY_;
};

inline void SSDL_SetCursor (int x, int y) { SSDL_StreamIOSystem::Instance().setCursor (x, y); }

template<class _Elem, class _Traits = std::char_traits <_Elem> >
class SSDL_BufferOut: public std::basic_streambuf<_Elem, _Traits>
{
public:
  typedef _Elem                           char_type;
  typedef _Traits                         traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::off_type off_type;
  typedef typename traits_type::pos_type pos_type;

  SSDL_BufferOut()  { } 
  void printChar (_Elem ch); 
protected:
  int_type overflow (int_type c = traits_type::eof ());
};

template <class charType, class TraitsType>
void SSDL_BufferOut<charType, TraitsType>::printChar (charType ch)
{
  int fontLineSkip = TTF_FontLineSkip ((TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont()); //and what font is that?
  int myAdvance;
  if (TTF_GlyphMetrics ((TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont(), ch, NULL, NULL, NULL, NULL, &myAdvance))
    throw "Oh, no!";
  static char buf[2] = {'\0'};
  //static int cursorX = 0, cursorY = 0; //DEFINITELY we will move this soon.

  switch (ch)
    {
    case '\n':
    case '\r':
      SSDL_StreamIOSystem::Instance().cursorY() += fontLineSkip;
      SSDL_StreamIOSystem::Instance().cursorX() =   0;
      break;
    case '\t':
      SSDL_StreamIOSystem::Instance().cursorX() = (((SSDL_StreamIOSystem::Instance().cursorX()/myAdvance)/8)+1)*8*myAdvance; //8 spaces per tab, by convention
      break;
    default:
      buf[0] = ch;
      SSDL_RenderText (buf, SSDL_StreamIOSystem::Instance().cursorX(), SSDL_StreamIOSystem::Instance().cursorY(), (TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont());
      SSDL_StreamIOSystem::Instance().cursorX() += myAdvance;
    }
}

template <class _ELem, class _Traits>
typename SSDL_BufferOut<_ELem, _Traits>::int_type
SSDL_BufferOut<_ELem, _Traits>::overflow (typename SSDL_BufferOut<_ELem, _Traits>::int_type c)
{
  printChar (c);
  //PRINT IT ON THE SCREEN -- I think!
  //return std::basic_filebuf<_ELem, _Traits>::overflow (c);

  //return something that isn't _Traits::eof() -- unless we fail somehow
  //What if we're passed eof?  Should we return failure (eof)?

  return 0; //Is this OK?
  //return (! _Traits::eof ());
}

template <class charT, class traits = std::char_traits<charT> >
class SSDL_BufferIn: public std::basic_streambuf<charT, traits>
{
public:
  enum {BUFFER_SIZE = 256};

  typedef charT                          char_type;
  typedef traits                         traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::off_type off_type;
  typedef typename traits_type::pos_type pos_type;

  SSDL_BufferIn ()
  {
    this->setg (buffer_, buffer_, buffer_);
    //This tells C++ where the read buffer starts, where it ends, and where the next char to read is
    // We offset it so there is an area to prepend things?  Don't know yet
  }
protected:
  int numCharsInBuffer () const { return int(this->egptr()-this->gptr()); }//it's the end position minus the next-char position
  char buffer_[BUFFER_SIZE]; //OK, but what if it grows too high? //should it be an int array?  setg says no

  int_type underflow ();
  int_type pbackfail (int_type c);
private:
  int_type  getMoreChars ();
  void egbump (int n)           //I wonder why this isn't built in?  moves end ptr by n units.
  {
    this->setg (this->eback(), this->gptr(), this->egptr()+n);
  }

  void handleBackspace(bool& charRemoved);			//used by getMoreChars ()
  void addACharacter(char c, bool& quit);				//used by getMoreChars ()
};

extern std::ostream sout;
extern std::istream ssin;

//As I understand it, underflow is here for when the istream class wants another character, it can get it
// from the source I provide (the buffer, if there is anything in it; if not, from the device that gives us chars)
template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::underflow ()
{
  if (numCharsInBuffer() > 0)				//If we have a char in the buffer to provide...
    return TraitsType::to_int_type (*(this->gptr()));	//... return it!  Job complete
  else if (getMoreChars ()>0)				//Can we get one from the device?
    return TraitsType::to_int_type (*(this->gptr()));	//If so, we did it; return the next char available
  else							//NO way to get a character!  Oh, no!  Return failure
    return TraitsType::eof ();
}

template <class charType, class TraitsType>
void SSDL_BufferIn<charType, TraitsType>::handleBackspace(bool& charRemoved)	//process a backspace in my input
{
  charRemoved = false;

  if (this->egptr() != this->eback() && SSDL_StreamIOSystem::Instance().cursorX() > 0) //last condition:  can we be assured it's right?  Cd we be
    //off by a few pixels?
    {
      char prevChar = *((this->egptr()) - 1);
      switch (prevChar)
	{
	case '\n':
	case '\r':
	case -1: //eof
	  break;
	default:
	  SSDL_StreamIOSystem::Instance().cursorX()
	    -= SSDL_Display::Instance().advance(prevChar);

	  SSDL_StreamIOSystem::Instance().eraseCharAtCursor(prevChar); //erase the char backspaced over

	  assert(SSDL_StreamIOSystem::Instance().cursorX() >= 0); //we shd've had at least 1 char on line, plus my new blank space!
	  egbump(-1); //move gptr back 1 space, so we're ignoring where we were
	  charRemoved = true;

	  break;
	}
    }
}

inline bool isNumLockOn (SDL_Keymod mod) { return (mod & KMOD_NUM) != 0; }

//We got a character through ssin... display it and send it where it should go.
template <class charType, class TraitsType>
void  SSDL_BufferIn<charType, TraitsType>::addACharacter(char c, bool& OKWereDone)
{
  if (this->gptr() >= this->eback() + BUFFER_SIZE - 1) //no room!
    {
      OKWereDone = true;	//What will this look like?  Test with tiny buffer size.
      return;
    }

  sout << c;
  *(this->egptr()) = c;
  egbump(1); //move end pointer one step further
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type  SSDL_BufferIn<charType, TraitsType>::getMoreChars ()
{
  //As it is, unless you backspace, you _never_ have gptr going back...and it should!  Can I be guaranteed
  // that every time istream calls underflow, it ate all the chars SSDL_BufferIn provided?  Yes!  So I will
  //move everything back.

  assert (this->eback () == buffer_); //if not, why not?
  if (this->gptr() != this->eback())
    memmove (this->eback(), this->gptr(), this->egptr()-this->gptr()); // I think this'll move things back!

  bool OKWereDone = false;
  int  numCharsRead = 0;

  while (! OKWereDone) //Looks a lot like SSDL_WaitEvent...
    {
      SDL_Event event;

      while (SDL_PollEvent(&event) != 0)
	{
	  SDL_Keymod   mod		= SDL_GetModState();
	  bool	     isNumLock	= isNumLockOn(mod);
	  SDL_Scancode scancode;

	  //If a quit message came, let's get out.
	  SSDL_CheckForQuitMessages(event);
	  if (SSDL_Display::Instance().isTimeToQuit())
	    {
	      OKWereDone = true;  break;
	    }

	  //Now let's process two kinds of messages.  SDL_KEYDOWN for when we get a backspace or a return
	  //SDL_TEXTINPUT for when we get useful, printable text.

	  switch (event.type)
	    {
	    case SDL_KEYDOWN:
	      scancode = event.key.keysym.scancode;
	      if (scancode == SDL_SCANCODE_BACKSPACE || (!isNumLock && scancode == SDL_SCANCODE_KP_BACKSPACE))
		{
		  bool charRemoved;
		  handleBackspace(charRemoved);
		  if (charRemoved) --numCharsRead;
		}
	      if (scancode == SDL_SCANCODE_RETURN || scancode == SDL_SCANCODE_RETURN2)
		{
		  OKWereDone = true;

		  addACharacter(event.key.keysym.sym, OKWereDone);		++numCharsRead;
		}
	      SSDL_RenderPresent();	//Let the user SEE what's being typed
	      break;
	    case SDL_TEXTINPUT:
	      addACharacter(event.text.text[0], OKWereDone);				++numCharsRead;
	      SSDL_RenderPresent();	//Let the user SEE what's being typed
	    }
	}
    }

  return numCharsRead;

  ////assert:  numCharsInBuffer() == 0, that is, gptr() == eback() == egptr(), that is, start==next==finish
  //int result = getCharsSomehow ();
  //if (result <= 0) return -1; //getChars failed; return failure.  Should NEVER HAPPEN
  //else
  //	setg (buffer_ ,
  //		  buffer_ ,
  //		  buffer_ +result;
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::pbackfail (int_type c)
{
  if (this->gptr() == this->eback ()) //if there is no further back we can go -- we're at start of buffer
    return TraitsType::eof (); //then failse
  else
    {
      this->gbump(-1); //back up one space
      //and if there's no EOF where we just went, put our char there
      if (! TraitsType::eq_int_type (c, TraitsType::eof ()))
	{
	  *(this->gptr()) = TraitsType::to_char_type (c);
	  return c;
	}
      else
	return TraitsType::not_eof(c);
    }
}


static bool isEscapeMeansQuit = true;

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{
  return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
  if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
  if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
      && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
    SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
  SSDL_RenderPresent();

  while (!SSDL_Display::Instance().isTimeToQuit())
    {
      if (SDL_WaitEvent(&sdlEvent) == 0) throw "Oh, no!";
      SSDL_CheckForQuitMessages(sdlEvent);
      if (sdlEvent.type == eventType) return;
    }
}

void SSDL_DefaultEventHandler()
{
  SSDL_Event event;

  while (SSDL_PollEvent(event))
    switch (event.type)
      {
      case SDL_QUIT:    SSDL_DeclareQuit(); break;
      case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();
      case SDL_WINDOWEVENT_MAXIMIZED:
      case SDL_WINDOWEVENT_RESTORED:    
      case SDL_WINDOWEVENT_SIZE_CHANGED:
      case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
	break;
      }
}

int  SSDL_WaitMouse()
{
  SDL_Event event;
  SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
  return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
  SDL_Event event;
  SSDL_WaitEvent(SDL_KEYDOWN, event);
  return event.key.keysym.sym;
}

//This is the SSDL_Display -- the screen you see when the program runs. 

#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#define FEDORA_FONT_PATH "/usr/share/fonts/msttcore/"
#define OPENSUSE_FONT_PATH "/usr/share/fonts/truetype/"
#define OPENSUSE_FONT_PATH_NEW "/usr/share/fonts/msttcorefonts/"
#define MANJARO_FONT_PATH "/usr/share/fonts/TTF"

SSDL_Display::SSDL_Display() : isTimeToQuit_(false)
{
  if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
    throw "Oh, no!";


  sdlWindow_ = SDL_CreateWindow("",              //no title by default
				SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
				DEFAULT_WIDTH, DEFAULT_HEIGHT,
				0);           //flags are 0 by default
  if (!sdlWindow_) throw "Oh, no!";

  //defaults below:  index shd be -1 (pick the first renderer that works best)
  //rendererFlags should be 0
  int rendererIndex = -1;
  int rendererFlags = 0;
  sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

  if (!sdlRenderer_) throw "Oh, no!";

  SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

  SDL_ClearError();
    
  static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
  if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw "Oh, no!";

  if (TTF_Init() == -1) throw "Oh, no!";

  SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);

  int point = 14;
  std::string filename = "arial.ttf"; 
  std::string finalFilename;

  systemFontPath_ = UBUNTU_FONT_PATH;
  finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
  if (!currentFont_) //OK, if it's not on the UBUNTU path, is it in the FEDORA path?
    {
      finalFilename = SSDL_SystemFontPath(FEDORA_FONT_PATH, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = FEDORA_FONT_PATH;
    }
  if (!currentFont_)  //If not, is it in the OPENSUSE path?
    {
      finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = OPENSUSE_FONT_PATH;
    }
  if (!currentFont_)  //If not, is it in the new OPENSUSE path? I find different paths for different installs of msttcore-fonts
    {
      finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH_NEW, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = OPENSUSE_FONT_PATH_NEW;
    }
  if (!currentFont_)  //If not, is it in the MANJARO path?
    {
      finalFilename = SSDL_SystemFontPath(MANJARO_FONT_PATH, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = MANJARO_FONT_PATH;
    }

  if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
      std::string errorMsg = std::string("Missing ") + filename +
	". Either msttcore fonts aren't installed or the path to them is unknown.\n"
	"If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";

      throw "Oh, no!"; 
    }

  TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
}

TTF_Font* SSDL_GetCurrentFont()
{
  return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
  SSDL_Display::Instance().setCurrentFont(newFont);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
  strcpy(temp, str);

  char* nextLine = strtok(temp, "\n\r");
  while (nextLine)
    {
      RenderTextLine(nextLine, x, y, font, isCentered);
      y += fontLineSkip();
      nextLine = strtok(NULL, "\n\r");
    }
  delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  SDL_Surface* surfaceToPrintOn;
  surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
  //arg -- having to cast away that const again.  Why should I have to?
  //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
  //I can fix this with my own calls
  if (!surfaceToPrintOn) throw "Oh, no!";


  SDL_Texture* textureToPrint;
  textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

  if (!textureToPrint) throw "Oh, no!";

  int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
  SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

  if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
    throw "Oh, no!";
  //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
  //Another time perhaps
  SDL_DestroyTexture(textureToPrint);
  SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
  return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}

void SSDL_RenderClear(const SSDL_Color& c)
{
  SSDL_Color old = SSDL_GetRenderDrawColor();
  SSDL_SetRenderDrawColor(c);
  SSDL_RenderClearAux();
  SSDL_SetRenderDrawColor(old);
}

//This is SSDL_Font, a wrapper for TTF_Font

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
  std::string newPath(fontPath); newPath += filename;
  if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
  return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
  string finalFilename;
  TTF_Font* currentFont_; //WSB: change to "result"

  //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "systemFontPath_", SSDL_Display::Instance().systemFontPath(), NULL);
  finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
  //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "final filename", finalFilename.c_str(), NULL);

  if (!currentFont_) 
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      throw "Oh, no!";
    }
  return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
  char* strEnd = (char*)str + strlen(str) - 1;
  char* substrEnd = (char*)substr + strlen(substr) - 1;

  for (;; --strEnd, --substrEnd)
    {
      if (toupper(*substrEnd) != toupper(*strEnd))  return false;

      if (substrEnd <= substr)    return true;
      else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
  SSDL_Display::Instance(); 

  string finalFilename = filename;
  if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

  TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
  if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      throw "Oh, no!";
    }
  return result;
}



static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
  SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
  //	SDL_Rect rect = {0, 0, 1, 1};

  //erase that last char by replacing with background color
  SDL_Rect newRect;
  newRect.x = cursorX(); newRect.y = cursorY();
  newRect.w = SSDL_Display::Instance().advance(c);
  newRect.h = SSDL_Display::Instance().fontLineSkip();
  Uint8 r, g, b, a;
  SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
  SSDL_Color background_ = SSDL_Display::Instance().background();
  SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
  SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
  SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
  SSDL_RenderPresent();

  SDL_FreeSurface(result);
}


int  getMoreChars ()
{
  bool OKWereDone = false;
  int  numCharsRead = 0;
  int x = 0, y = 0;
  
  while (! OKWereDone) //Looks a lot like SSDL_WaitEvent...
    {
      SDL_Event event;
      SSDL_RenderPresent();

      while (SDL_PollEvent(&event) != 0)
	{
	  SDL_Keymod   mod		= SDL_GetModState();
	  bool	     isNumLock	= isNumLockOn(mod);
	  SDL_Scancode scancode;

	  //If a quit message came, let's get out.
	  SSDL_CheckForQuitMessages(event);
	  if (SSDL_Display::Instance().isTimeToQuit())
	    {
	      OKWereDone = true;  break;
	    }

	  //Now let's process two kinds of messages.  SDL_KEYDOWN for when we get a backspace or a return
	  //SDL_TEXTINPUT for when we get useful, printable text.

	  switch (event.type)
	    {
	    case SDL_KEYDOWN:
	      scancode = event.key.keysym.scancode;
	      if (scancode == SDL_SCANCODE_BACKSPACE || (!isNumLock && scancode == SDL_SCANCODE_KP_BACKSPACE))
		{
		  bool charRemoved;
		  //handleBackspace(charRemoved);
		  if (charRemoved) --numCharsRead;
		}
	      if (scancode == SDL_SCANCODE_RETURN || scancode == SDL_SCANCODE_RETURN2)
		{
		  OKWereDone = true;

		  SSDL_RenderText (event.key.keysym.sym, x, y); x+= 10;
		}
	      break;
	    case SDL_TEXTINPUT:
		  SSDL_RenderText (event.text.text[0], x, y); x+= 10;
	    }
	}
    }

  return numCharsRead;
}


int main (int argc, char** argv)
{
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();

  getMoreChars ();
  //std::string str;  ssin >> str;
  
  return 0;
}
