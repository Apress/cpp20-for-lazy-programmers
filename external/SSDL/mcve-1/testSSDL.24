#include <cmath> //for sqrt
#include <sstream>
#include <cstring> //for strcmp
#include <string>
#include <SDL.h>
#include <exception>
#include <cstring> 
#include <SDL_ttf.h>

void setCrashMessage(const std::string& msg);

using namespace std;

#include "SDL.h"

struct SSDL_Color : public SDL_Color
{
public:
    constexpr SSDL_Color (SDL_Color& other) : SDL_Color(other) {}
	//The : SDL_Color() below is for backward compatibility: C++20 doesn't require it, but
	// 6-7-2020 VS gave a warning
	constexpr SSDL_Color (int rIn = 0, int gIn = 0, int bIn = 0, int alpha = 255) : SDL_Color()
	{
		r = rIn; g = gIn; b = bIn; a = alpha;
	}
	constexpr SSDL_Color            (const SSDL_Color& other) = default;
	constexpr SSDL_Color& operator= (const SSDL_Color& other) = default;
	
	constexpr bool operator== (const SSDL_Color& other) const
	{
		return r == other.r && g == other.g&& b == other.b && a == other.a;
	}
};

//6-8-2020: I could replace this with inline constexpr, but for backward compatibility
// I won't just yet
extern const SSDL_Color BLACK, WHITE, RED, GREEN, BLUE;

inline constexpr SSDL_Color SSDL_CreateColor (int r, int g, int b, int a=255) { return SSDL_Color (r, g, b, a); }

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), GREEN (0, 255, 0);

//#include "SSDL_exception.h"
/*Simple SDL, a wrapper library for SDL.
  
  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

//This is ssdl_exception.cpp, which provides an exception class that SSDL throws

#include <iostream>
#include <string>
#include <SDL.h>

class SSDL_Exception 
{
public:
	SSDL_Exception(const char* message = SDL_GetError()) : contents_(message) {}
	/*SSDL_Exception () : contents_ (SDL_GetError ()) 
	{
	}*/
	void print (std::ostream& out) const{ out << contents_;          }
	operator const std::string () const { return contents_;			 }
	operator const char*	   () const { return contents_.c_str (); }
private:
	std::string contents_;
};

inline
std::ostream& operator<< (std::ostream& out, const SSDL_Exception& foo)
{
	foo.print (out); return out;
}

void SSDL_terminate() //DOES NOT GET CALLED when we are in the Debugger
{
  abort();
}



//#include "SSDL_display.h"
/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

//This is the SSDL_Display -- the screen you see when the program runs. 

#include <sstream>
#include <SDL.h>
#include <SDL_ttf.h>
//#include "SSDL_font.h"
/*Simple SDL, a wrapper library for SDL.

  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

//This is SSDL_Font.
//Since it's a wrapper, it is essentially TTF_Font*, only it has memory management.

#include <memory>
#include <SDL_ttf.h>

//Because TTF_Font* must be destructed by TTF_CloseFont... and because shared_ptr
// instead calls a dtor... and TTF_Font won't allow inheritance from it...
// I am intentionally ignoring a possible memory leak.  May address this later. 10/10/19

class SSDL_Font
{
public:
        SSDL_Font(TTF_Font* font = NULL) : ttfFont_(NULL)
        {
                ttfFont_.reset(font, TTF_CloseFont);
        }
        SSDL_Font(const SSDL_Font& f) { *this = f; }

        const SSDL_Font& operator= (const SSDL_Font& f) { ttfFont_ = f.ttfFont_; return *this; }
        operator       TTF_Font* ()       { return ttfFont_.get(); }
        operator       TTF_Font* () const { return ttfFont_.get(); }

private:
        std::shared_ptr<TTF_Font> ttfFont_;
};

TTF_Font* SSDL_OpenFont           (const char* filename, int point);
        //This bit all relates to where to get fonts found on the system

//All this does is set up the full path for a font -- used in
// SSDL_display.*, SSDL_font.*

std::string SSDL_SystemFontPath(const char* fontPath, const char* filename);

TTF_Font* SSDL_OpenSystemFont  (const char* filename, int point);

        //What font is current?
TTF_Font* SSDL_GetCurrentFont();
void      SSDL_SetFont(TTF_Font* newFont);

        //Useful for adding (or not) ".ttf" to the end of filenames
bool matchFromEnd(const char* str, const char* substr);

//#include "SSDL_singletonManager.h"

class SSDL_Image;

class SSDL_Display
{
        friend void atexitHandler(); //I advise against friends...but every rule has an exception.
public:
        enum {DEFAULT_WIDTH = 640, DEFAULT_HEIGHT = 480};

        SSDL_Display                  (const SSDL_Display&) = delete;
        const SSDL_Display& operator= (const SSDL_Display&) = delete;

        static SSDL_Display& Instance ()
        {
                static SSDL_Display myInstance;
                return myInstance;
        }       

        void RenderTextLine    (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
        void RenderText        (const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
        //void scrollVertically  (unsigned int pixels); //Not currently done; maybe nice in next version

        bool isTimeToQuit () const { return isTimeToQuit_; }
        void declareTimeToQuit ()  { isTimeToQuit_ = true; }

        operator SDL_Renderer* () const { return sdlRenderer_; }
        operator SDL_Window*   () const { return sdlWindow_;   }

        void setWindowSize (int w, int h);

        int  advance(char ch) const
        {
                int result;
                if (TTF_GlyphMetrics ((TTF_Font*) (const TTF_Font*) SSDL_GetCurrentFont(), ch, NULL, NULL, NULL, NULL, &result))
                        throw SSDL_Exception ();
                return result;
        }
        int fontLineSkip () const
        {
                return TTF_FontLineSkip((TTF_Font*) SSDL_GetCurrentFont());
                //return TTF_FontLineSkip ((TTF_Font*) (const TTF_Font*) currentFont());
                //why the double cast?  SDL_ttf library's never heard of const -- so we must first convert to ptr, then discard const
        }


        const SSDL_Color& background () const { return background_; }
        void     setBackground (const SSDL_Color& c) { background_ = c; }

        TTF_Font* currentFont() const { return currentFont_; }
        void setCurrentFont(TTF_Font* newFont) { currentFont_ = newFont; }
        const char* systemFontPath () const { return systemFontPath_.c_str();}
private:
        SDL_Window*   sdlWindow_;
        SDL_Renderer* sdlRenderer_;
        TTF_Font*         currentFont_;
        std::string   systemFontPath_;
        SSDL_Color        background_;

        bool              isTimeToQuit_;

        SSDL_Display  ();       
        ~SSDL_Display ();
};



inline bool SSDL_IsQuit      () { return SSDL_Display::Instance().isTimeToQuit(); }
inline void SSDL_DeclareQuit () { SSDL_Display::Instance().declareTimeToQuit();   }

inline void SSDL_SetRenderDrawColor (const SSDL_Color& c)
{
        SDL_SetRenderDrawColor(SSDL_Display::Instance(), c.r, c.g, c.b, c.a);   
}

inline SSDL_Color SSDL_GetRenderDrawColor ()
{
        SSDL_Color c;
        SDL_GetRenderDrawColor (SSDL_Display::Instance(), &c.r, &c.g, &c.b, &c.a);
        return c;
}

inline void SSDL_SetRenderEraseColor (const SSDL_Color& c)
{
        SSDL_Display::Instance().setBackground (c);
}

inline const SSDL_Color& SSDL_GetRenderEraseColor ()
{
        return SSDL_Display::Instance().background();
}

inline void SSDL_RenderClearAux ()
{
        if (SDL_RenderClear (SSDL_Display::Instance()) < 0) throw SSDL_Exception ();
}

void SSDL_RenderClear(const SSDL_Color& c = SSDL_Display::Instance().background());

inline
void SSDL_RenderTextAux (const char* str, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
        SSDL_Display::Instance().RenderText (str, x, y, font);
}

inline
void SSDL_RenderTextCenteredAux (const char* str, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
        SSDL_Display::Instance().RenderText (str, x, y, font, true); //true for "yes, center it"
}

template <typename T>
inline
void SSDL_RenderTextCentered (const T& thing, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
        std::ostringstream os; os << thing;
        SSDL_RenderTextCenteredAux (os.str().c_str(), x, y, font);
}

template <typename T>
inline
void SSDL_RenderText (const T& thing, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
        std::ostringstream os; os << thing;
        SSDL_RenderTextAux (os.str().c_str(), x, y, font);
}

//...I could do a template specialization here, but it doesn't seem necessary.  It will slow printing of
// strings ever so slightly if I don't.

inline void SSDL_RenderImage (SDL_Texture* image, const SDL_Rect& src, const SDL_Rect& dst)
{
        if (SDL_RenderCopy (SSDL_Display::Instance(), image, &src, &dst) != 0) throw SSDL_Exception ();
}

inline void SSDL_RenderImageEx (SDL_Texture* image, const SDL_Rect& src, const SDL_Rect& dst, double angleInDegrees = 0.0,
                                                                SDL_RendererFlip flipValue = SDL_FLIP_NONE)
{
        SDL_RenderCopyEx (SSDL_Display::Instance(), image, &src, &dst, angleInDegrees, NULL, flipValue);
}

inline void SSDL_QueryImage (SDL_Texture* image, int& w, int& h)
{
        SDL_QueryTexture (image, NULL, NULL, &w, &h);
}

inline int SSDL_GetImageWidth  (SDL_Texture* image) { int w, h; SSDL_QueryImage (image, w, h); return w; }
inline int SSDL_GetImageHeight (SDL_Texture* image) { int w, h; SSDL_QueryImage (image, w, h); return h; }

void SSDL_RenderImage (SDL_Texture* image, int x, int y, int stretchWidth=0, int stretchHeight=0);

inline void SSDL_RenderPresent () { SDL_RenderPresent (SSDL_Display::Instance ()); }

inline void SSDL_GetWindowPosition(int&        x, int&        y)
{
        SDL_GetWindowPosition ( SSDL_Display::Instance(), &x, &y);
}
inline void SSDL_GetWindowSize (int& x, int& y)
{
        SDL_GetWindowSize     (SSDL_Display::Instance(), &x, &y);
}
inline const char*      SSDL_GetWindowTitle ()                          { return SDL_GetWindowTitle (SSDL_Display::Instance()); }
inline void                     SSDL_SetWindowTitle(const char* t)      { SDL_SetWindowTitle (SSDL_Display::Instance(), t);             }
inline void                     SSDL_SetWindowPosition (int x,int y){ SDL_SetWindowPosition(SSDL_Display::Instance(), x,y); }
inline void                     SSDL_RestoreWindow  ()                          { SDL_RestoreWindow (SSDL_Display::Instance());                 }
inline void                     SSDL_MinimizeWindow ()                          { SDL_MinimizeWindow(SSDL_Display::Instance());                 }
inline void                     SSDL_MaximizeWindow ()                          { SDL_MaximizeWindow(SSDL_Display::Instance());                 }
inline int          SSDL_GetWindowWidth ()              { int w, h; SSDL_GetWindowSize (w, h); return w;        }
inline int                      SSDL_GetWindowHeight()                          { int w, h; SSDL_GetWindowSize (w, h); return h;                }

inline void                     SSDL_SetWindowSize(int w, int h)        { SSDL_Display::Instance().setWindowSize(w, h); }

//SSDL_stream.h stuff

#include <cassert>
//#include "SSDL_io.h"
/*Simple SDL, a wrapper library for SDL.
  
  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */
  
//Various functions related to I/O (mouse or keyboard)

typedef SDL_Event SSDL_Event; //simple renaming -- now you can use either

bool SSDL_IsKeyPressed (SDL_Keycode whichKey);

inline int SSDL_GetMouseClick (){ return SDL_GetMouseState (NULL, NULL);		  }
inline int SSDL_GetMouseX()		{ int x, y; SDL_GetMouseState (&x, &y); return x; }
inline int SSDL_GetMouseY()		{ int x, y; SDL_GetMouseState (&x, &y); return y; }

void SSDL_WaitEvent (Uint32 eventType, SDL_Event& event);
//Note that these wait functions also stop waiting if you get a SDL_QUIT event.
//Should I also stop waiting if someone hits Esc?  I could do that, but make it
// conditional (you can turn it off)
//Note:  You CANNOT OR events together -- they are not distinct bits!

int         SSDL_WaitMouse();
SDL_Keycode SSDL_WaitKey  (); //SDL_Keycode is SDL's virtual key rep. *Sometimes* casting to char gets you what you hit

void SSDL_ToggleEscapeIsQuit ();

inline int SSDL_PollEvent (SDL_Event& event) { return SDL_PollEvent (&event); }

void SSDL_DefaultEventHandler ();

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent);


//#include "SSDL_image.h"
/*Simple SDL, a wrapper library for SDL.
  
  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

//This is SSDL_Image.h.  Since it's a wrapper, it can handle whatever image formats
//  SDL2_Image supports.

//Essentially it's SDL_Texture* except that it has a destructor.  

#include <memory>
#include <SDL_image.h>

inline
void SSDL_DestroyTexture(SDL_Texture*& p) //A workaround, because you need to call SDL_DestroyTexture on SDL_Textures,
                                          // not just delete
{
	if (p) 
	{ 
		SDL_DestroyTexture(p); 
		p = nullptr; 
	}
}

class SSDL_Image
{
public:
	SSDL_Image() : sdlTexture_(NULL)  {  }
	SSDL_Image (SDL_Texture* sdlTexture) : sdlTexture_ (NULL) 
	{ 
		sdlTexture_.reset(sdlTexture, SSDL_DestroyTexture);
	}
	SSDL_Image(const SSDL_Image& other) { *this = other;  }

	operator       SDL_Texture* ()		 { return sdlTexture_.get (); }
	operator       SDL_Texture* () const { return sdlTexture_.get (); }
	
	const SSDL_Image& operator= (const SSDL_Image& other)
	{
		sdlTexture_ = other.sdlTexture_; return *this;
	}
private:
	std::shared_ptr<SDL_Texture> sdlTexture_;	//yes, I do need to use SDL_Texture not SDL_Surface.  
								//Efficiency.  Wd be less efficient if we manipulate the
								// bits... but we won't.
};

SSDL_Image SSDL_LoadImage(const char* filename);





class SSDL_StreamIOSystem
{
public:
  static SSDL_StreamIOSystem& Instance ()
  {
    static SSDL_StreamIOSystem myStreamIOSystem;
    return myStreamIOSystem;
  }
  SSDL_StreamIOSystem(const SSDL_StreamIOSystem&) = delete;
  const SSDL_StreamIOSystem& operator= (const SSDL_StreamIOSystem&) = delete;

  TTF_Font* currentFont () const { return SSDL_GetCurrentFont (); }

  int  cursorX() const { return cursorX_; }
  int  cursorY() const { return cursorY_; }
  int& cursorX()		 { return cursorX_; }
  int& cursorY()		 { return cursorY_; }
  void setCursor (int x, int y) { cursorX_ = x; cursorY_ = y; }
  void eraseCharAtCursor (char c); //should not be called after changing font... odd things'll happen

private:
  SSDL_StreamIOSystem () : /*currentFont_ (NULL), */cursorX_(0), cursorY_(0)
  {
  }

  int cursorX_, cursorY_;
};

inline void SSDL_SetCursor (int x, int y) { SSDL_StreamIOSystem::Instance().setCursor (x, y); }

template<class _Elem, class _Traits = std::char_traits <_Elem> >
class SSDL_BufferOut: public std::basic_streambuf<_Elem, _Traits>
{
public:
  typedef _Elem                           char_type;
  typedef _Traits                         traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::off_type off_type;
  typedef typename traits_type::pos_type pos_type;

  SSDL_BufferOut()  { } 
  void printChar (_Elem ch); 
protected:
  int_type overflow (int_type c = traits_type::eof ());
};

template <class charType, class TraitsType>
void SSDL_BufferOut<charType, TraitsType>::printChar (charType ch)
{
  //fontLineSkip is how far to go down to next line
  //advance is how far to go right to next char
  //it varies except in fixed-width font
  //This may blow away my hope of saving time by sending entire strings -- or not.  Not sure
  // it'll be O(N) to find the advance, but I don't know how long it takes to render a string

  //Why all this casting to TTF_Font*?  Because SDL2_ttf library hasn't heard of const, so it objects
  // when I send a const pointer.
  int fontLineSkip = TTF_FontLineSkip ((TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont()); //and what font is that?
  int myAdvance;
  if (TTF_GlyphMetrics ((TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont(), ch, NULL, NULL, NULL, NULL, &myAdvance))
    throw SSDL_Exception ();
  static char buf[2] = {'\0'};
  //static int cursorX = 0, cursorY = 0; //DEFINITELY we will move this soon.

  switch (ch)
    {
    case '\n':
    case '\r':
      SSDL_StreamIOSystem::Instance().cursorY() += fontLineSkip;
      SSDL_StreamIOSystem::Instance().cursorX() =   0;
      break;
    case '\t':
      SSDL_StreamIOSystem::Instance().cursorX() = (((SSDL_StreamIOSystem::Instance().cursorX()/myAdvance)/8)+1)*8*myAdvance; //8 spaces per tab, by convention
      break;
    default:
      buf[0] = ch;
      SSDL_RenderText (buf, SSDL_StreamIOSystem::Instance().cursorX(), SSDL_StreamIOSystem::Instance().cursorY(), (TTF_Font*) (const TTF_Font*) SSDL_StreamIOSystem::Instance().currentFont());
      SSDL_StreamIOSystem::Instance().cursorX() += myAdvance;
    }
}

template <class _ELem, class _Traits>
typename SSDL_BufferOut<_ELem, _Traits>::int_type
SSDL_BufferOut<_ELem, _Traits>::overflow (typename SSDL_BufferOut<_ELem, _Traits>::int_type c)
{
  //This is likely inefficient:  better to send big chunks rather than individual chunks
  //Later, make SSDL use this aright.  For now...
  printChar (c);
  //PRINT IT ON THE SCREEN -- I think!
  //return std::basic_filebuf<_ELem, _Traits>::overflow (c);

  //return something that isn't _Traits::eof() -- unless we fail somehow
  //What if we're passed eof?  Should we return failure (eof)?

  return 0; //Is this OK?
  //return (! _Traits::eof ());
}

template <class charT, class traits = std::char_traits<charT> >
class SSDL_BufferIn: public std::basic_streambuf<charT, traits>
{
public:
  enum {BUFFER_SIZE = 256};

  typedef charT                          char_type;
  typedef traits                         traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::off_type off_type;
  typedef typename traits_type::pos_type pos_type;

  SSDL_BufferIn ()
  {
    this->setg (buffer_, buffer_, buffer_);
    //This tells C++ where the read buffer starts, where it ends, and where the next char to read is
    // We offset it so there is an area to prepend things?  Don't know yet
  }
protected:
  int numCharsInBuffer () const { return int(this->egptr()-this->gptr()); }//it's the end position minus the next-char position
  char buffer_[BUFFER_SIZE]; //OK, but what if it grows too high? //should it be an int array?  setg says no

  int_type underflow ();
  int_type pbackfail (int_type c);
private:
  int_type  getMoreChars ();
  void egbump (int n)           //I wonder why this isn't built in?  moves end ptr by n units.
  {
    this->setg (this->eback(), this->gptr(), this->egptr()+n);
  }

  void handleBackspace(bool& charRemoved);			//used by getMoreChars ()
  void addACharacter(char c, bool& quit);				//used by getMoreChars ()
};

extern std::ostream sout;
extern std::istream ssin;

//As I understand it, underflow is here for when the istream class wants another character, it can get it
// from the source I provide (the buffer, if there is anything in it; if not, from the device that gives us chars)
template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::underflow ()
{
  if (numCharsInBuffer() > 0)						//If we have a char in the buffer to provide...
    return TraitsType::to_int_type (*(this->gptr()));	//... return it!  Job complete
  else if (getMoreChars ()>0)						//Can we get one from the device?
    return TraitsType::to_int_type (*(this->gptr()));	//If so, we did it; return the next char available
  else											//NO way to get a character!  Oh, no!  Return failure
    return TraitsType::eof ();
}

template <class charType, class TraitsType>
void SSDL_BufferIn<charType, TraitsType>::handleBackspace(bool& charRemoved)	//process a backspace in my input
{
  charRemoved = false;

  if (this->egptr() != this->eback() && SSDL_StreamIOSystem::Instance().cursorX() > 0) //last condition:  can we be assured it's right?  Cd we be
    //off by a few pixels?
    {
      char prevChar = *((this->egptr()) - 1);
      switch (prevChar)
	{
	case '\n':
	case '\r':
	case -1: //eof
	  break;
	default:
	  SSDL_StreamIOSystem::Instance().cursorX()
	    -= SSDL_Display::Instance().advance(prevChar);

	  SSDL_StreamIOSystem::Instance().eraseCharAtCursor(prevChar); //erase the char backspaced over

	  assert(SSDL_StreamIOSystem::Instance().cursorX() >= 0); //we shd've had at least 1 char on line, plus my new blank space!
	  egbump(-1); //move gptr back 1 space, so we're ignoring where we were
	  charRemoved = true;

	  break;
	}
    }
}

inline bool isNumLockOn (SDL_Keymod mod) { return (mod & KMOD_NUM) != 0; }

//We got a character through ssin... display it and send it where it should go.
template <class charType, class TraitsType>
void  SSDL_BufferIn<charType, TraitsType>::addACharacter(char c, bool& OKWereDone)
{
  if (this->gptr() >= this->eback() + BUFFER_SIZE - 1) //no room!
    {
      OKWereDone = true;	//What will this look like?  Test with tiny buffer size.
      return;
    }

  sout << c;
  *(this->egptr()) = c;
  egbump(1); //move end pointer one step further
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type  SSDL_BufferIn<charType, TraitsType>::getMoreChars ()
{
  //As it is, unless you backspace, you _never_ have gptr going back...and it should!  Can I be guaranteed
  // that every time istream calls underflow, it ate all the chars SSDL_BufferIn provided?  Yes!  So I will
  //move everything back.

  assert (this->eback () == buffer_); //if not, why not?
  if (this->gptr() != this->eback())
    memmove (this->eback(), this->gptr(), this->egptr()-this->gptr()); // I think this'll move things back!

  bool OKWereDone = false;
  int  numCharsRead = 0;

  while (! OKWereDone) //Looks a lot like SSDL_WaitEvent...
    {
      SDL_Event event;
      SSDL_RenderPresent();	//Why this?  because it's annoying to have the screen not update while you're
      //waiting for an event!

      while (SDL_PollEvent(&event) != 0)
	{
	  SDL_Keymod   mod		= SDL_GetModState();
	  bool	     isNumLock	= isNumLockOn(mod);
	  SDL_Scancode scancode;

	  //If a quit message came, let's get out.
	  SSDL_CheckForQuitMessages(event);
	  if (SSDL_Display::Instance().isTimeToQuit())
	    {
	      OKWereDone = true;  break;
	    }

	  //Now let's process two kinds of messages.  SDL_KEYDOWN for when we get a backspace or a return
	  //SDL_TEXTINPUT for when we get useful, printable text.

	  switch (event.type)
	    {
	    case SDL_KEYDOWN:
	      scancode = event.key.keysym.scancode;
	      if (scancode == SDL_SCANCODE_BACKSPACE || (!isNumLock && scancode == SDL_SCANCODE_KP_BACKSPACE))
		{
		  bool charRemoved;
		  handleBackspace(charRemoved);
		  if (charRemoved) --numCharsRead;
		}
	      if (scancode == SDL_SCANCODE_RETURN || scancode == SDL_SCANCODE_RETURN2)
		{
		  OKWereDone = true;

		  addACharacter(event.key.keysym.sym, OKWereDone);		++numCharsRead;
		}
	      break;
	    case SDL_TEXTINPUT:
	      addACharacter(event.text.text[0], OKWereDone);				++numCharsRead;
	    }
	}
    }

  return numCharsRead;

  ////assert:  numCharsInBuffer() == 0, that is, gptr() == eback() == egptr(), that is, start==next==finish
  //int result = getCharsSomehow ();
  //if (result <= 0) return -1; //getChars failed; return failure.  Should NEVER HAPPEN
  //else
  //	setg (buffer_ ,
  //		  buffer_ ,
  //		  buffer_ +result;
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::pbackfail (int_type c)
{
  if (this->gptr() == this->eback ()) //if there is no further back we can go -- we're at start of buffer
    return TraitsType::eof (); //then failse
  else
    {
      this->gbump(-1); //back up one space
      //and if there's no EOF where we just went, put our char there
      if (! TraitsType::eq_int_type (c, TraitsType::eof ()))
	{
	  *(this->gptr()) = TraitsType::to_char_type (c);
	  return c;
	}
      else
	return TraitsType::not_eof(c);
    }
}


static bool isEscapeMeansQuit = true;

bool SSDL_IsKeyPressed(SDL_Keycode whichKey)
{
  return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
  if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
  if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
      && sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
    SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
  SSDL_RenderPresent();

  while (!SSDL_Display::Instance().isTimeToQuit())
    {
      if (SDL_WaitEvent(&sdlEvent) == 0) throw SSDL_Exception();
      SSDL_CheckForQuitMessages(sdlEvent);
      if (sdlEvent.type == eventType) return;
    }
}

void SSDL_DefaultEventHandler()
{
  SSDL_Event event;

  while (SSDL_PollEvent(event))
    switch (event.type)
      {
      case SDL_QUIT:    SSDL_DeclareQuit(); break;
      case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();
      case SDL_WINDOWEVENT_MAXIMIZED:
      case SDL_WINDOWEVENT_RESTORED:    
      case SDL_WINDOWEVENT_SIZE_CHANGED:
      case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
	break;
      }
}

int  SSDL_WaitMouse()
{
  SDL_Event event;
  SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
  return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
  SDL_Event event;
  SSDL_WaitEvent(SDL_KEYDOWN, event);
  return event.key.keysym.sym;
}

//This is the SSDL_Display -- the screen you see when the program runs. 

#define UBUNTU_FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#define FEDORA_FONT_PATH "/usr/share/fonts/msttcore/"
#define OPENSUSE_FONT_PATH "/usr/share/fonts/truetype/"
#define OPENSUSE_FONT_PATH_NEW "/usr/share/fonts/msttcorefonts/"
#define MANJARO_FONT_PATH "/usr/share/fonts/TTF"

SSDL_Display::SSDL_Display() : isTimeToQuit_(false)
{
  std::set_terminate(SSDL_terminate);

  if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
    throw SSDL_Exception();


  sdlWindow_ = SDL_CreateWindow("",              //no title by default
				SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
				DEFAULT_WIDTH, DEFAULT_HEIGHT,
				0);           //flags are 0 by default
  if (!sdlWindow_) throw SSDL_Exception();

  //defaults below:  index shd be -1 (pick the first renderer that works best)
  //rendererFlags should be 0
  int rendererIndex = -1;
  int rendererFlags = 0;
  sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

  if (!sdlRenderer_) throw SSDL_Exception();

  SDL_SetRenderDrawColor(sdlRenderer_, 0, 0, 0, 255); SDL_RenderClear(sdlRenderer_);

  SDL_ClearError();
    
  static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
  if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw SSDL_Exception();

  if (TTF_Init() == -1) throw SSDL_Exception();

  SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);

  int point = 14;
  std::string filename = "arial.ttf"; 
  std::string finalFilename;

  systemFontPath_ = UBUNTU_FONT_PATH;
  finalFilename = SSDL_SystemFontPath(systemFontPath(), filename.c_str());
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
  if (!currentFont_) //OK, if it's not on the UBUNTU path, is it in the FEDORA path?
    {
      finalFilename = SSDL_SystemFontPath(FEDORA_FONT_PATH, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = FEDORA_FONT_PATH;
    }
  if (!currentFont_)  //If not, is it in the OPENSUSE path?
    {
      finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = OPENSUSE_FONT_PATH;
    }
  if (!currentFont_)  //If not, is it in the new OPENSUSE path? I find different paths for different installs of msttcore-fonts
    {
      finalFilename = SSDL_SystemFontPath(OPENSUSE_FONT_PATH_NEW, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = OPENSUSE_FONT_PATH_NEW;
    }
  if (!currentFont_)  //If not, is it in the MANJARO path?
    {
      finalFilename = SSDL_SystemFontPath(MANJARO_FONT_PATH, filename.c_str());
      currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
      systemFontPath_ = MANJARO_FONT_PATH;
    }

  if (!currentFont_)//Note: VS doesn't thereby do a popup window. Other systems do
    {
      std::string errorMsg = std::string("Missing ") + filename +
	". Either msttcore fonts aren't installed or the path to them is unknown.\n"
	"If it's the path (on Unix), see SSDL_Display for where to add it (search for this message).";

      setCrashMessage(errorMsg); 
      throw SSDL_Exception(errorMsg.c_str());
    }

  TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
}

SSDL_Display::~SSDL_Display()
{
}

TTF_Font* SSDL_GetCurrentFont()
{
  return SSDL_Display::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont)
{
  SSDL_Display::Instance().setCurrentFont(newFont);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
  strcpy(temp, str);

  char* nextLine = strtok(temp, "\n\r");
  while (nextLine)
    {
      RenderTextLine(nextLine, x, y, font, isCentered);
      y += fontLineSkip();
      nextLine = strtok(NULL, "\n\r");
    }
  delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
  SDL_Surface* surfaceToPrintOn;
  surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
  //arg -- having to cast away that const again.  Why should I have to?
  //I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
  //I can fix this with my own calls
  if (!surfaceToPrintOn) throw SSDL_Exception();


  SDL_Texture* textureToPrint;
  textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

  if (!textureToPrint) throw SSDL_Exception();

  int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
  SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

  if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
    throw SSDL_Exception();
  //If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
  //Another time perhaps
  SDL_DestroyTexture(textureToPrint);
  SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
  return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}


void SSDL_RenderClear(const SSDL_Color& c)
{
  SSDL_Color old = SSDL_GetRenderDrawColor();
  SSDL_SetRenderDrawColor(c);
  SSDL_RenderClearAux();
  SSDL_SetRenderDrawColor(old);
}

void SSDL_Display::setWindowSize(int w, int h)
{
#ifdef __unix__
  SDL_Event e; while (SDL_PollEvent(&e));
#endif
  //In Unix sometimes if I don't to this, the
  //next call to SDL_GetWindowSize will get the old
  //dimensions, not the new. Go figure.

  SDL_SetWindowSize(SSDL_Display::Instance(), w, h);

#ifdef __unix__
  SDL_RenderPresent(SSDL_Display::Instance());
  for (int i = 0; i < 40; ++i) //Must be 6 or more to be reliable
    SDL_Delay(30);          //10 works; 1 doesn't
  //A single SDL_Delay(60); usually works
  //but sometimes does not
  //The current numbers 40x30, are there to make it work with OpenSuSe. Would like to have
  // a more rational long-term fix. Maybe SDL.org will have one by now.
#endif
}

//This is SSDL_Font, a wrapper for TTF_Font

//All this does is set up the full path for a font
std::string SSDL_SystemFontPath(const char* fontPath, const char* filename)
{
  std::string newPath(fontPath); newPath += filename;
  if (!matchFromEnd(filename, ".ttf")) newPath += ".ttf";
  return newPath;
}

TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
  string finalFilename;
  TTF_Font* currentFont_; //WSB: change to "result"

  //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "systemFontPath_", SSDL_Display::Instance().systemFontPath(), NULL);
  finalFilename = SSDL_SystemFontPath(SSDL_Display::Instance().systemFontPath(), filename);
  currentFont_ = TTF_OpenFont(finalFilename.c_str(), point);
  //      SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "final filename", finalFilename.c_str(), NULL);

  if (!currentFont_) 
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      setCrashMessage(errorMsg); 
      throw SSDL_Exception();
    }
  return currentFont_;
}

bool matchFromEnd(const char* str, const char* substr)
{
  char* strEnd = (char*)str + strlen(str) - 1;
  char* substrEnd = (char*)substr + strlen(substr) - 1;

  for (;; --strEnd, --substrEnd)
    {
      if (toupper(*substrEnd) != toupper(*strEnd))  return false;

      if (substrEnd <= substr)    return true;
      else if (strEnd <= str)     return false;
    }
}

TTF_Font* SSDL_OpenFont(const char* filename, int point)
{
  SSDL_Display::Instance(); 

  string finalFilename = filename;
  if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

  TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
  if (!result) //Note: VS doesn't thereby do a popup window. Other systems do
    {
      std::string errorMsg = std::string("Can't open font ") + filename + ".";
      setCrashMessage(errorMsg); 
      throw SSDL_Exception();
    }
  return result;
}


//#include "SSDL_timer.h"
/*Simple SDL, a wrapper library for SDL.
  
  Copyright (C) 2020 Will Briggs.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. */

//Timer-related functions.  I also need delay; wait for mouse; wait for key

void SSDL_SetFramesPerSecond (Uint32 FPS);

bool SSDL_IsNextFrame  (); //updates screen, verifies there's no quit message found earlier
bool SSDL_IsQuitMessage(); //updates screen, polls events, verifies there's no (possibly new) quit message

inline void SSDL_Delay (Uint32 milliseconds) 
{ 
	if (SSDL_IsQuitMessage ()) return; //Hitting Esc or killing window will
									   // skip the delay to come.  Won't interrupt
									   // the delay if it's already going.  Fixable?
	SSDL_RenderPresent (); SDL_Delay (milliseconds); 
} 



static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
  SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
  //	SDL_Rect rect = {0, 0, 1, 1};

  //erase that last char by replacing with background color
  SDL_Rect newRect;
  newRect.x = cursorX(); newRect.y = cursorY();
  newRect.w = SSDL_Display::Instance().advance(c);
  newRect.h = SSDL_Display::Instance().fontLineSkip();
  Uint8 r, g, b, a;
  SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
  SSDL_Color background_ = SSDL_Display::Instance().background();
  SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
  SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
  SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
  SSDL_RenderPresent();

  SDL_FreeSurface(result);
}


class SSDL_Timer
{
public:
  static SSDL_Timer& Instance()
  {
    static SSDL_Timer myInstance;
    return myInstance;
  }

  SSDL_Timer(const SSDL_Timer&) = delete;
  const SSDL_Timer& operator= (const SSDL_Timer&) = delete;

  void setFramesPerSecond(Uint32 fps) { frameDuration_ = 1000 / fps; }
  //maybe I shd just do frame duration as 1/60 of a second?
  bool sync();
private:
  SSDL_Timer() : timeAtNextFrame_(0)
  {
    setFramesPerSecond(60);	//default to 60 frames per second.
  }

  Uint32 frameDuration_;		//in milliseconds
  Uint32 timeAtNextFrame_;	//in milliseconds, counting from time we started SDL
};

// Frame Per Second Function  , put this in a loop
bool SSDL_Timer::sync()
{
  if (SSDL_Display::Instance().isTimeToQuit()) return false;

  SSDL_RenderPresent();

  Uint32 currentTime = SDL_GetTicks();
  if (timeAtNextFrame_ > currentTime)
    SDL_Delay(timeAtNextFrame_ - currentTime);

  timeAtNextFrame_ = currentTime + frameDuration_;

  return true;
}

bool SSDL_IsQuitMessage()
{
  SSDL_DefaultEventHandler(); return !SSDL_IsNextFrame();
}

void SSDL_SetFramesPerSecond(Uint32 FPS) { SSDL_Timer::Instance().setFramesPerSecond(FPS); }
bool SSDL_IsNextFrame() { return SSDL_Timer::Instance().sync(); }


//#include "SSDL_singletonManager.h"

void atexitHandler();

class SSDL_SingletonManager
{
public:
  SSDL_SingletonManager()
  {
    atexit(atexitHandler);
    SSDL_Display::Instance();
  }
  std::string crashMessage;
};

static SSDL_SingletonManager singletonManagerInstance;

void setCrashMessage(const std::string& msg)
{
  singletonManagerInstance.crashMessage = msg;
}

void atexitHandler()
{
  if (singletonManagerInstance.crashMessage.length()) //if there was a crash message...display it
    SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", singletonManagerInstance.crashMessage.c_str(), NULL);

}


int main (int argc, char** argv)
{
  SSDL_SetRenderEraseColor(GREEN); SSDL_RenderClear();

  std::string str;  ssin >> str;

  return 0;
}
